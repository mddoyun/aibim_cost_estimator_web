<!--templates/ifc_ai_prediction/prediction.html-->

{% load static %}
<!DOCTYPE html>
<html>
  <head>
    <title>IFC AI 예측 - {{ project.name }}</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, user-scalable=no"
    />

    <!-- three.js / OrbitControls ES module importmap -->
    <script type="importmap">
      {
        "imports": {
          "three": "{% static 'js/three.module.js' %}",
          "three/examples/jsm/controls/OrbitControls.js": "{% static 'js/OrbitControls.js' %}"
        }
      }
    </script>
    <script
      async
      src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
    ></script>

    <!-- Pyodide + IfcOpenShell WASM -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.22.0a1/full/pyodide.js"></script>

    <!-- TensorFlow.js, Chart.js, JSZip -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

    <!-- CSS -->
    <link
      rel="stylesheet"
      href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
    />
    <link rel="stylesheet" href="{% static 'css/main.css' %}" />

    <style>
      body {
        background: #f8f9fa;
        margin: 0;
        padding: 0;
      }

      .nav-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 15px 0;
        margin-bottom: 0;
      }
      .nav-links {
        text-align: center;
      }
      .nav-links a {
        color: white;
        text-decoration: none;
        margin: 0 15px;
        padding: 8px 16px;
        border-radius: 4px;
        transition: background 0.3s ease;
      }
      .nav-links a:hover {
        background: rgba(255, 255, 255, 0.2);
        text-decoration: none;
        color: white;
      }

      .project-info {
        background: white;
        padding: 15px;
        border-bottom: 1px solid #dee2e6;
      }

      .main-container {
        display: grid;
        grid-template-columns: 1fr 400px;
        gap: 20px;
        padding: 20px;
        height: calc(100vh - 180px);
      }

      .left-panel {
        display: grid;
        grid-template-rows: 300px 1fr;
        gap: 20px;
      }

      .viewer-container {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        overflow: hidden;
      }

      #viewer {
        width: 100%;
        height: 100%;
      }

      .objects-container {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        padding: 20px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }

      .objects-header {
        display: flex;
        justify-content: between;
        align-items: center;
        margin-bottom: 15px;
        border-bottom: 1px solid #dee2e6;
        padding-bottom: 10px;
      }

      .group-controls {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
        flex-wrap: wrap;
      }

      .group-controls select {
        flex: 1;
        min-width: 120px;
        padding: 5px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 12px;
      }

      .objects-table-container {
        flex: 1;
        overflow: auto;
        border: 1px solid #dee2e6;
        border-radius: 4px;
      }

      .objects-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 11px;
      }

      .objects-table th,
      .objects-table td {
        padding: 6px 8px;
        border-bottom: 1px solid #dee2e6;
        text-align: left;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 150px;
      }

      .objects-table th {
        background: #f8f9fa;
        font-weight: 600;
        position: sticky;
        top: 0;
        z-index: 10;
      }

      .objects-table tbody tr:hover {
        background: #f0f8ff;
        cursor: pointer;
      }

      .group-header {
        background: #e9ecef !important;
        font-weight: bold;
        cursor: pointer;
      }

      .group-header:hover {
        background: #dee2e6 !important;
      }

      .right-panel {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        padding: 20px;
        overflow-y: auto;
      }

      .section-header {
        font-size: 16px;
        font-weight: 600;
        color: #495057;
        margin-bottom: 15px;
        padding-bottom: 8px;
        border-bottom: 2px solid #667eea;
      }

      .model-selector {
        margin-bottom: 20px;
      }

      .model-selector select {
        width: 100%;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
      }

      .input-mapping-container {
        margin-bottom: 20px;
      }

      .input-item {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 15px;
        margin-bottom: 15px;
      }

      .input-header {
        font-weight: 600;
        color: #495057;
        margin-bottom: 10px;
      }

      .mapping-type-selector {
        margin-bottom: 10px;
      }

      .mapping-type-selector label {
        margin-right: 15px;
        font-weight: normal;
      }

      .manual-input {
        width: 100%;
        padding: 6px;
        border: 1px solid #ddd;
        border-radius: 4px;
      }

      .filter-condition {
        background: #fff;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 10px;
        margin-bottom: 8px;
      }

      .filter-row {
        display: flex;
        gap: 8px;
        align-items: center;
        margin-bottom: 5px;
      }

      .filter-row select,
      .filter-row input {
        flex: 1;
        min-width: 80px;
        padding: 4px;
        border: 1px solid #ddd;
        border-radius: 3px;
        font-size: 11px;
      }

      .btn-small {
        padding: 4px 8px;
        font-size: 11px;
        border: none;
        border-radius: 3px;
        cursor: pointer;
      }

      .btn-add {
        background: #28a745;
        color: white;
      }

      .btn-remove {
        background: #dc3545;
        color: white;
      }

      .btn-test {
        background: #17a2b8;
        color: white;
      }

      .aggregation-controls {
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px solid #ddd;
      }

      .aggregation-row {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .aggregation-result {
        background: #d4edda;
        border: 1px solid #c3e6cb;
        color: #155724;
        padding: 8px;
        border-radius: 4px;
        margin-top: 8px;
        font-weight: 600;
      }

      .btn-predict {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
        width: 100%;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .btn-predict:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
      }

      .btn-predict:disabled {
        background: #6c757d;
        cursor: not-allowed;
      }

      .prediction-result {
        background: #d1ecf1;
        border: 1px solid #bee5eb;
        color: #0c5460;
        padding: 15px;
        border-radius: 6px;
        margin-top: 15px;
      }

      .result-chart {
        margin-top: 15px;
        text-align: center;
      }

      .loading {
        text-align: center;
        padding: 20px;
        color: #6c757d;
      }

      .hidden {
        display: none;
      }
      /* 테이블 선택 표시 */
      .objects-table tr.selected-row {
        background: #ffe8a1 !important;
      }
    </style>
  </head>
  <body data-project-id="{{ project.id }}">
    <!-- 네비게이션 헤더 -->
    <div id="page-wrapper">
      <!-- Header -->
      <div id="header">
        <!-- Logo -->
        <h1>
          <a href="/" id="logo">AIBIM <em>Cost Estimator</em></a>
        </h1>

        <!-- Nav -->
        <nav id="nav">
          <ul>
            <li><a href="/">홈</a></li>
            <li>
              <a href="#">계획설계단계 견적</a>
              <ul>
                <li>
                  <a href="/ai_prediction/">AI 개산견적</a>
                </li>
              </ul>
            </li>
            <li class="current">
              <a href="#">중간설계단계 견적</a>
              <ul>
                <li>
                  <a href="/ifc_ai_prediction/">AI+BIM 개산견적(IFC기반)</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="#">실시설계단계 견적</a>
              <ul>
                <li>
                  <a href="/dd_by_ifc/">AI+BIM 상세견적(IFC기반)</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="/ai_learning">AI모델 학습</a>
            </li>
          </ul>
        </nav>
      </div>

      <div id="nav_sub">
        <h6 class="text-center">
          <b>AI+BIM 개산견적</b> <span>(IFC기반)</span>
        </h6>
      </div>
    </div>

    <!-- 프로젝트 정보 -->
    <div class="project-info">
      <div class="container">
        <h4 style="margin: 0; color: #495057">
          <i class="fas fa-brain"></i>
          {{ project.name }} - AI 예측
        </h4>
        <small class="text-muted">{{ project.description }}</small>
      </div>
    </div>

    <!-- 메인 컨테이너 -->
    <div class="main-container">
      <!-- 좌측 패널 -->
      <div class="left-panel">
        <!-- 3D 뷰어 -->
        <div class="viewer-container">
          <div id="viewer"></div>
        </div>

        <!-- IFC 객체 테이블 -->
        <div class="objects-container">
          <div class="objects-header">
            <h5 style="margin: 0">IFC 객체 정보</h5>
            <span id="objectCount" class="text-muted">로딩 중...</span>
          </div>

          <div class="group-controls">
            <select id="groupBy1">
              <option value="">1차 그룹: 없음</option>
            </select>
            <select id="groupBy2">
              <option value="">2차 그룹: 없음</option>
            </select>
            <select id="groupBy3">
              <option value="">3차 그룹: 없음</option>
            </select>
          </div>

          <div class="objects-table-container">
            <table class="objects-table" id="objectsTable">
              <thead>
                <tr id="tableHeaders">
                  <th>로딩 중...</th>
                </tr>
              </thead>
              <tbody id="tableBody">
                <tr>
                  <td class="loading">
                    <i class="fas fa-spinner fa-spin"></i>
                    IFC 객체 데이터를 로딩하고 있습니다...
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>

      <!-- 우측 패널 (AI 예측 설정) -->
      <div class="right-panel">
        <div class="section-header">AI 모델 선택</div>

        <div class="model-selector">
          <select id="aiModelSelect">
            <option value="">AI 모델을 선택하세요</option>
            {% for model in ai_models %}
            <option value="{{ model.id }}">{{ model.name }}</option>
            {% endfor %}
          </select>
        </div>

        <div id="modelInfo" class="hidden">
          <div class="section-header">모델 정보</div>
          <div id="modelDetails"></div>
        </div>

        <div id="inputMappingSection" class="hidden">
          <div class="section-header">입력 설정</div>
          <div id="inputMappingContainer"></div>

          <button id="predictBtn" class="btn-predict" disabled>
            <i class="fas fa-brain"></i>
            예측 실행
          </button>
        </div>

        <div id="predictionResult" class="hidden">
          <div class="section-header">예측 결과</div>
          <div id="resultContent"></div>
          <div id="resultChart" class="result-chart"></div>

          <button
            id="downloadPdfBtn"
            class="btn btn-success btn-block mt-3"
            onclick="downloadPredictionPDF()"
          >
            <i class="fas fa-file-pdf"></i>
            PDF 다운로드
          </button>
        </div>
      </div>
    </div>

    <!-- Scripts -->
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"
      referrerpolicy="no-referrer"
    />

    <style>
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
    </style>

    <style>
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
    </style>

    <!-- 로딩 스피너 HTML (3D 뷰어 컨테이너 안에 추가) -->
    <div
      id="viewer-loading"
      style="
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 1000;
        text-align: center;
        background: rgba(255, 255, 255, 0.9);
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      "
    >
      <div
        style="
          width: 40px;
          height: 40px;
          border: 4px solid #f3f3f3;
          border-top: 4px solid #667eea;
          border-radius: 50%;
          animation: spin 1s linear infinite;
          margin: 0 auto 10px;
        "
      ></div>
      <div style="color: #495057; font-weight: 600">모델 로딩중...</div>
    </div>

    <style>
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
    <!-- 메인 스크립트 -->
    <script>
      // 전역 변수
      const PROJECT_ID = parseInt(document.body.dataset.projectId);
      let objectData = [];
      let headers = [];
      let groupedObjects = [];
      let selectedModel = null;
      let sessionKey = null;
      let inputMappings = {};
      let loadedAIModel = null;
      let lastPredictionData = null;
      let currentMappingId = null;
      // === 선택 동기화용 맵/상태 ===
      const guidToRow = new Map();
      let isSyncingFromViewer = false; // 루프 방지용

      // ===== Multi‑Select Sync (Table <-> 3D) =====
      const selectedGuids = new Set(); // 현재 선택된 guid들
      let lastClickedRowIdx = -1; // 테이블에서 shift 범위 선택용
      let isSyncingFromTable = false; // 테이블->뷰어 동기화 중?

      // 테이블 선택 스타일 적용
      function applyTableSelectionStyles() {
        document.querySelectorAll("#tableBody tr.object-row").forEach((tr) => {
          if (selectedGuids.has(tr.dataset.guid))
            tr.classList.add("selected-row");
          else tr.classList.remove("selected-row");
        });
      }

      // 테이블 클릭 처리
      function handleTableRowClick(e, guid, row) {
        const idx = parseInt(row.dataset.idx, 10);
        const additive = e.ctrlKey || e.metaKey; // 개별 토글
        const range = e.shiftKey && lastClickedRowIdx >= 0; // 범위 선택

        if (range) {
          const rows = Array.from(
            document.querySelectorAll("#tableBody tr.object-row")
          );
          const [start, end] =
            idx > lastClickedRowIdx
              ? [lastClickedRowIdx, idx]
              : [idx, lastClickedRowIdx];
          for (let i = start; i <= end; i++)
            selectedGuids.add(rows[i].dataset.guid);
        } else {
          if (!additive) selectedGuids.clear(); // 기본은 단일 선택
          if (additive && selectedGuids.has(guid)) selectedGuids.delete(guid);
          else selectedGuids.add(guid);
        }

        lastClickedRowIdx = idx;
        applyTableSelectionStyles();

        // 뷰어로 동기화
        if (window.ifcViewer && !isSyncingFromViewer) {
          isSyncingFromTable = true;
          window.ifcViewer.setSelection(Array.from(selectedGuids)); // 새로 만든 API (3번에서 구현)
          isSyncingFromTable = false;
        }
      }

      // 테이블에서 GUID들 세트로 선택 강제(뷰어 -> 테이블)
      function selectRowsByGuids(guidsArray) {
        selectedGuids.clear();
        guidsArray.forEach((g) => selectedGuids.add(g));
        applyTableSelectionStyles();
      }

      // 페이지 로딩 시 초기화
      document.addEventListener("DOMContentLoaded", function () {
        loadIFCObjects();
        setupEventHandlers();
      });

      // 이벤트 핸들러 설정
      function setupEventHandlers() {
        // AI 모델 선택
        document
          .getElementById("aiModelSelect")
          .addEventListener("change", loadModelInfo);

        // 그룹 콤보박스
        for (let i = 1; i <= 3; i++) {
          document
            .getElementById("groupBy" + i)
            .addEventListener("change", updateGroupedTable);
        }

        // 예측 실행
        document
          .getElementById("predictBtn")
          .addEventListener("click", executePrediction);
      }

      // IFC 객체 데이터 로드
      function loadIFCObjects() {
        fetch(`/ifc_ai_prediction/api/project/${PROJECT_ID}/objects/`)
          .then((response) => response.json())
          .then((data) => {
            objectData = data.objects;
            headers = data.headers;

            document.getElementById(
              "objectCount"
            ).textContent = `총 ${data.total_count}개 객체`;

            updateGroupComboBoxes();
            updateGroupedTable();
          })
          .catch((error) => {
            console.error("IFC 객체 로드 실패:", error);
            document.getElementById("objectCount").textContent = "로딩 실패";
          });
      }

      function createObjectRow(obj, visibleHeaders, idx) {
        const row = document.createElement("tr");
        row.className = "object-row";
        row.dataset.idx = idx;

        const guid =
          obj["GlobalId"] ||
          obj["globalId"] ||
          obj["IfcGuid"] ||
          obj["ifcGuid"] ||
          obj["GUID"] ||
          obj["Guid"] ||
          null;

        row.dataset.guid = guid || "";

        visibleHeaders.forEach((header) => {
          const cell = document.createElement("td");
          let value = obj[header];
          if (typeof value === "number")
            value = value.toLocaleString("ko-KR", { maximumFractionDigits: 2 });
          cell.textContent = value ?? "";
          cell.title = value ?? "";
          row.appendChild(cell);
        });

        row.addEventListener("click", (e) => {
          if (!guid) return;
          handleTableRowClick(e, guid, row); // (e, guid, row) 버전만 존재해야 함
        });

        if (guid) guidToRow.set(guid, row);
        return row;
      }

      // 객체들을 키로 그룹화
      function groupObjectsByKeys(objects, keys, depth = 0) {
        if (depth >= keys.length) return objects;

        const grouped = {};
        const key = keys[depth];

        objects.forEach((obj) => {
          let value = obj[key] || "N/A";
          if (!grouped[value]) grouped[value] = [];
          grouped[value].push(obj);
        });

        Object.keys(grouped).forEach((key) => {
          grouped[key] = groupObjectsByKeys(grouped[key], keys, depth + 1);
        });

        return grouped;
      }

      function renderGroupedData(
        tbody,
        groupedData,
        depth,
        groupKeys,
        visibleHeaders,
        rowCounterRef
      ) {
        Object.entries(groupedData).forEach(([groupValue, content]) => {
          const groupRow = document.createElement("tr");
          groupRow.className = "group-header";

          const groupCell = document.createElement("td");
          groupCell.colSpan = visibleHeaders.length;
          groupCell.textContent = `${"  ".repeat(depth)}▼ ${
            groupKeys[depth]
          }: ${groupValue}`;
          groupRow.appendChild(groupCell);

          tbody.appendChild(groupRow);

          if (Array.isArray(content)) {
            content.forEach((obj) => {
              const row = createObjectRow(obj, visibleHeaders, rowCounterRef++);
              tbody.appendChild(row);
            });
          } else {
            rowCounterRef = renderGroupedData(
              tbody,
              content,
              depth + 1,
              groupKeys,
              visibleHeaders,
              rowCounterRef
            );
          }
        });
        return rowCounterRef;
      }

      // AI 모델 정보 로드
      function loadModelInfo() {
        const modelId = document.getElementById("aiModelSelect").value;

        if (!modelId) {
          document.getElementById("modelInfo").classList.add("hidden");
          document
            .getElementById("inputMappingSection")
            .classList.add("hidden");
          return;
        }

        fetch(`/ifc_ai_prediction/api/model/${modelId}/metadata/`)
          .then((response) => response.json())
          .then((data) => {
            selectedModel = data;
            displayModelInfo(data);
            loadAIModel(data);
            createInputMappingUI(data);
          })
          .catch((error) => {
            console.error("모델 정보 로드 실패:", error);
            alert("모델 정보를 로드할 수 없습니다.");
          });
      }

      // AI 모델 로드 (TensorFlow.js)
      async function loadAIModel(modelMetadata) {
        try {
          // ZIP 파일에서 모델 로드
          const modelResponse = await fetch(modelMetadata.model_file_url);
          const zipBlob = await modelResponse.blob();

          const zip = new JSZip();
          const zipContent = await zip.loadAsync(zipBlob);

          // model.json 읽기
          const modelJson = await zipContent.file("model.json").async("string");
          const modelTopology = JSON.parse(modelJson);

          // weights.bin 읽기
          const weightsData = await zipContent
            .file("weights.bin")
            .async("uint8array");

          // TensorFlow.js 모델 로드
          loadedAIModel = await tf.loadLayersModel(
            tf.io.fromMemory(modelTopology, weightsData)
          );

          console.log("✅ AI 모델 로드 완료");
        } catch (error) {
          console.error("❌ AI 모델 로드 실패:", error);
          alert("AI 모델을 로드할 수 없습니다: " + error.message);
        }
      }

      // 모델 정보 표시
      function displayModelInfo(model) {
        const details = `
                <div style="background: #f8f9fa; padding: 12px; border-radius: 4px; font-size: 13px;">
                    <strong>설명:</strong> ${model.description || "없음"}<br>
                    <strong>입력 변수:</strong> ${model.input_columns.join(
                      ", "
                    )}<br>
                    <strong>출력 변수:</strong> ${model.output_columns.join(
                      ", "
                    )}<br>
                    ${
                      model.rmse
                        ? `<strong>RMSE:</strong> ${model.rmse.toFixed(4)}<br>`
                        : ""
                    }
                    ${
                      model.mae
                        ? `<strong>MAE:</strong> ${model.mae.toFixed(4)}<br>`
                        : ""
                    }
                    ${
                      model.r2_score
                        ? `<strong>R² 점수:</strong> ${model.r2_score.toFixed(
                            4
                          )}`
                        : ""
                    }
                </div>
            `;

        document.getElementById("modelDetails").innerHTML = details;
        document.getElementById("modelInfo").classList.remove("hidden");
      }

      // 입력 매핑 UI 생성 (핵심 기능!)
      function createInputMappingUI(model) {
        const container = document.getElementById("inputMappingContainer");
        container.innerHTML = "";

        inputMappings = {};

        model.input_columns.forEach((column, index) => {
          const inputDiv = document.createElement("div");
          inputDiv.className = "input-item";
          inputDiv.innerHTML = `
                    <div class="input-header">${column}</div>
                    
                    <div class="mapping-type-selector">
                        <label>
                            <input type="radio" name="type_${index}" value="manual" checked>
                            직접 입력
                        </label>
                        <label>
                            <input type="radio" name="type_${index}" value="ifc_aggregation">
                            IFC 객체 집계
                        </label>
                    </div>
                    
                    <div class="manual-input-container">
                        <input type="number" class="manual-input" data-column="${column}" 
                               placeholder="값을 입력하세요" step="any">
                    </div>
                    
                    <div class="ifc-aggregation-container hidden">
                        <div class="filter-conditions" data-column="${column}">
                            <!-- 필터 조건들이 여기에 추가됨 -->
                        </div>
                        <button type="button" class="btn-small btn-add" onclick="addFilterCondition('${column}')">
                            + 조건 추가
                        </button>
                        
                        <div class="aggregation-controls">
                            <div class="aggregation-row">
                                <select class="aggregation-attribute" data-column="${column}">
                                    <option value="">집계할 속성 선택</option>
                                    ${headers
                                      .map(
                                        (h) =>
                                          `<option value="${h}">${h}</option>`
                                      )
                                      .join("")}
                                </select>
                                <select class="aggregation-function" data-column="${column}">
                                    <option value="sum">합계</option>
                                    <option value="count">개수</option>
                                    <option value="avg">평균</option>
                                    <option value="min">최솟값</option>
                                    <option value="max">최댓값</option>
                                </select>
                                <button type="button" class="btn-small btn-test" onclick="testAggregation('${column}')">
                                    테스트
                                </button>
                            </div>
                            <div class="aggregation-result hidden" data-column="${column}"></div>
                        </div>
                    </div>
                `;

          container.appendChild(inputDiv);

          // 라디오 버튼 이벤트
          inputDiv
            .querySelectorAll(`input[name="type_${index}"]`)
            .forEach((radio) => {
              radio.addEventListener("change", function () {
                const manualContainer = inputDiv.querySelector(
                  ".manual-input-container"
                );
                const ifcContainer = inputDiv.querySelector(
                  ".ifc-aggregation-container"
                );

                if (this.value === "manual") {
                  manualContainer.classList.remove("hidden");
                  ifcContainer.classList.add("hidden");
                } else {
                  manualContainer.classList.add("hidden");
                  ifcContainer.classList.remove("hidden");
                }

                updateInputMapping(column);
              });
            });

          // 직접 입력 이벤트
          inputDiv
            .querySelector(".manual-input")
            .addEventListener("input", function () {
              updateInputMapping(column);
            });

          // 집계 설정 이벤트
          inputDiv
            .querySelector(".aggregation-attribute")
            .addEventListener("change", function () {
              updateInputMapping(column);
            });
          inputDiv
            .querySelector(".aggregation-function")
            .addEventListener("change", function () {
              updateInputMapping(column);
            });

          // 초기 매핑 설정
          updateInputMapping(column);
        });

        document
          .getElementById("inputMappingSection")
          .classList.remove("hidden");
        updatePredictButton();
      }

      // 입력 매핑 업데이트
      function updateInputMapping(column) {
        const inputDiv = document
          .querySelector(`[data-column="${column}"]`)
          .closest(".input-item");
        const type = inputDiv.querySelector(
          'input[name^="type_"]:checked'
        ).value;

        if (type === "manual") {
          const value = inputDiv.querySelector(".manual-input").value;
          inputMappings[column] = {
            type: "manual",
            value: value || 0,
          };
        } else {
          const attribute = inputDiv.querySelector(
            ".aggregation-attribute"
          ).value;
          const func = inputDiv.querySelector(".aggregation-function").value;

          inputMappings[column] = {
            type: "ifc_aggregation",
            aggregation_attribute: attribute,
            aggregation_function: func,
            filters: [], // 필터 조건들은 별도로 관리
          };
        }

        updatePredictButton();
      }

      // 필터 조건 추가 (사용자가 설명한 복잡한 UI)
      function addFilterCondition(column) {
        const container = document.querySelector(
          `.filter-conditions[data-column="${column}"]`
        );
        const conditionDiv = document.createElement("div");
        conditionDiv.className = "filter-condition";

        const conditionCount = container.children.length;
        const relationHtml =
          conditionCount > 0
            ? `
                <select class="relation-select">
                    <option value="and">그리고</option>
                    <option value="or">또는</option>
                </select>
            `
            : "";

        conditionDiv.innerHTML = `
                ${relationHtml}
                <div class="filter-row">
                    <select class="attribute-select">
                        <option value="">속성 선택</option>
                        ${headers
                          .map((h) => `<option value="${h}">${h}</option>`)
                          .join("")}
                    </select>
                    <input type="text" class="value-input" placeholder="속성값">
                    <select class="condition-select">
                        <option value="equals">같음</option>
                        <option value="contains">포함</option>
                        <option value="starts_with">시작함</option>
                        <option value="ends_with">끝남</option>
                        <option value="greater_than">보다 큼</option>
                        <option value="less_than">보다 작음</option>
                        <option value="greater_equal">크거나 같음</option>
                        <option value="less_equal">작거나 같음</option>
                    </select>
                    <button type="button" class="btn-small btn-remove" onclick="removeFilterCondition(this)">
                        -
                    </button>
                </div>
            `;

        container.appendChild(conditionDiv);
      }

      // 필터 조건 제거
      function removeFilterCondition(button) {
        button.closest(".filter-condition").remove();
      }

      // 집계 테스트
      function testAggregation(column) {
        const inputDiv = document
          .querySelector(`[data-column="${column}"]`)
          .closest(".input-item");
        const attribute = inputDiv.querySelector(
          ".aggregation-attribute"
        ).value;
        const func = inputDiv.querySelector(".aggregation-function").value;

        if (!attribute) {
          alert("집계할 속성을 선택하세요.");
          return;
        }

        // 필터 조건들 수집
        const conditions = [];
        const filterContainer = inputDiv.querySelector(".filter-conditions");

        filterContainer
          .querySelectorAll(".filter-condition")
          .forEach((condition, index) => {
            const attrSelect = condition.querySelector(".attribute-select");
            const condSelect = condition.querySelector(".condition-select");
            const valueInput = condition.querySelector(".value-input");
            const relationSelect = condition.querySelector(".relation-select");

            if (attrSelect.value && condSelect.value && valueInput.value) {
              conditions.push({
                attribute_name: attrSelect.value,
                condition: condSelect.value,
                value: valueInput.value,
                relation: index > 0 ? relationSelect.value : "and",
              });
            }
          });

        // 서버에 필터 조건 저장
        fetch("/ifc_ai_prediction/api/filters/save/", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            session_key: sessionKey,
            conditions: conditions,
          }),
        })
          .then((response) => response.json())
          .then((data) => {
            sessionKey = data.session_key;

            // 집계 테스트
            return fetch(
              `/ifc_ai_prediction/api/project/${PROJECT_ID}/test-aggregation/`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  filter_session_key: sessionKey,
                  aggregation_attribute: attribute,
                  aggregation_function: func,
                }),
              }
            );
          })
          .then((response) => response.json())
          .then((data) => {
            if (data.success) {
              const resultDiv = inputDiv.querySelector(
                `.aggregation-result[data-column="${column}"]`
              );
              resultDiv.innerHTML = `
                        <strong>결과:</strong> ${data.result.toLocaleString(
                          "ko-KR",
                          { maximumFractionDigits: 2 }
                        )}<br>
                        <small>필터링된 객체: ${
                          data.filtered_count
                        }개, 집계된 값: ${data.values_count}개</small>
                    `;
              resultDiv.classList.remove("hidden");
            } else {
              alert("집계 테스트 실패: " + data.error);
            }
          })
          .catch((error) => {
            console.error("집계 테스트 실패:", error);
            alert("집계 테스트 중 오류가 발생했습니다.");
          });
      }

      // 예측 버튼 상태 업데이트
      function updatePredictButton() {
        const btn = document.getElementById("predictBtn");
        const allInputsValid =
          Object.keys(inputMappings).length ===
          selectedModel?.input_columns.length;

        btn.disabled = !allInputsValid || !loadedAIModel;
      }

      // 예측 실행 (핵심!)
      function executePrediction() {
        if (!selectedModel || !loadedAIModel) {
          alert("AI 모델을 선택하고 로드를 완료하세요.");
          return;
        }

        const btn = document.getElementById("predictBtn");
        btn.disabled = true;
        btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 예측 중...';

        // 예측 실행 요청 (입력 데이터 계산)
        fetch(
          `/ifc_ai_prediction/api/project/${PROJECT_ID}/execute-prediction/`,
          {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              ai_model_id: selectedModel.id,
              input_mappings: inputMappings,
            }),
          }
        )
          .then((response) => response.json())
          .then((data) => {
            if (data.success) {
              currentMappingId = data.mapping_id;
              // TensorFlow.js로 실제 예측 실행
              performPrediction(data.input_values, data.execution_time);
            } else {
              throw new Error(data.error);
            }
          })
          .catch((error) => {
            console.error("예측 실행 실패:", error);
            alert("예측 실행 중 오류가 발생했습니다: " + error.message);

            btn.disabled = false;
            btn.innerHTML = '<i class="fas fa-brain"></i> 예측 실행';
          });
      }

      // TensorFlow.js 예측 수행
      async function performPrediction(inputValues, executionTime) {
        try {
          // 입력 데이터를 텐서로 변환
          const inputArray = selectedModel.input_columns.map(
            (col) => inputValues[col] || 0
          );
          const inputTensor = tf.tensor2d([inputArray]);

          // 예측 실행
          const prediction = await loadedAIModel.predict(inputTensor);
          const predictionArray = await prediction.data();
          const predictionValue = predictionArray[0];

          // 오차 범위 계산
          const errorRange = calculateErrorRange(predictionValue);

          // 결과 표시
          displayPredictionResult(
            predictionValue,
            errorRange,
            inputValues,
            executionTime
          );

          // 예측 결과 저장
          await savePrediction(inputValues, predictionValue, errorRange);

          // 메모리 정리
          inputTensor.dispose();
          prediction.dispose();
        } catch (error) {
          console.error("예측 수행 실패:", error);
          alert("예측 수행 중 오류가 발생했습니다: " + error.message);
        } finally {
          // 버튼 복원
          const btn = document.getElementById("predictBtn");
          btn.disabled = false;
          btn.innerHTML = '<i class="fas fa-brain"></i> 예측 실행';
        }
      }

      // 오차 범위 계산
      function calculateErrorRange(prediction) {
        const rmse = selectedModel.rmse || 0;
        const mae = selectedModel.mae || 0;

        const errorMargin = rmse * 1.5;

        return {
          min: Math.max(0, prediction - errorMargin),
          max: prediction + errorMargin,
          confidence: Math.max(0, Math.min(1, 1 - rmse / prediction)),
        };
      }

      // 예측 결과 표시
      function displayPredictionResult(
        prediction,
        errorRange,
        inputValues,
        executionTime
      ) {
        const resultContent = document.getElementById("resultContent");

        // PDF 생성용 데이터 저장
        lastPredictionData = {
          input_values: inputValues,
          prediction_result: { value: prediction },
          prediction_range: errorRange,
        };

        resultContent.innerHTML = `
                <div class="prediction-result">
                    <h5 style="margin-bottom: 15px; color: #0c5460;">
                        <i class="fas fa-chart-line"></i> 예측 결과
                    </h5>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                        <div>
                            <strong>예측값:</strong><br>
                            <span style="font-size: 1.4em; color: #28a745;">${prediction.toLocaleString(
                              "ko-KR",
                              { maximumFractionDigits: 2 }
                            )}</span>
                        </div>
                        <div>
                            <strong>신뢰도:</strong><br>
                            <span style="font-size: 1.4em; color: #17a2b8;">${(
                              errorRange.confidence * 100
                            ).toFixed(1)}%</span>
                        </div>
                    </div>
                    
                    <div style="background: rgba(255,255,255,0.7); padding: 10px; border-radius: 4px;">
                        <strong>예측 범위:</strong><br>
                        최솟값: ${errorRange.min.toLocaleString("ko-KR", {
                          maximumFractionDigits: 2,
                        })}<br>
                        최댓값: ${errorRange.max.toLocaleString("ko-KR", {
                          maximumFractionDigits: 2,
                        })}<br>
                        오차 범위: ±${(
                          (errorRange.max - errorRange.min) /
                          2
                        ).toLocaleString("ko-KR", { maximumFractionDigits: 2 })}
                    </div>
                </div>
                
                <div style="margin-top: 15px;">
                    <h6>입력값 요약</h6>
                    <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; font-size: 13px;">
                        ${Object.entries(inputValues)
                          .map(
                            ([key, value]) =>
                              `<div>${key}: ${value.toLocaleString("ko-KR", {
                                maximumFractionDigits: 2,
                              })}</div>`
                          )
                          .join("")}
                    </div>
                </div>
            `;

        document.getElementById("predictionResult").classList.remove("hidden");

        // 차트 생성
        createResultChart(prediction, errorRange);
      }

      // 결과 차트 생성
      function createResultChart(result, range) {
        const chartContainer = document.getElementById("resultChart");
        chartContainer.innerHTML =
          '<canvas id="resultCanvas" width="300" height="200"></canvas>';

        const ctx = document.getElementById("resultCanvas").getContext("2d");

        new Chart(ctx, {
          type: "bar",
          data: {
            labels: ["최솟값", "예측값", "최댓값"],
            datasets: [
              {
                label: "예측 결과",
                data: [range.min, result, range.max],
                backgroundColor: [
                  "rgba(255, 193, 7, 0.8)",
                  "rgba(40, 167, 69, 0.8)",
                  "rgba(220, 53, 69, 0.8)",
                ],
                borderColor: [
                  "rgba(255, 193, 7, 1)",
                  "rgba(40, 167, 69, 1)",
                  "rgba(220, 53, 69, 1)",
                ],
                borderWidth: 2,
              },
            ],
          },
          options: {
            responsive: true,
            scales: {
              y: {
                beginAtZero: false,
              },
            },
            plugins: {
              legend: {
                display: false,
              },
            },
          },
        });
      }

      // 예측 결과 저장
      async function savePrediction(inputValues, prediction, errorRange) {
        if (!currentMappingId) return;

        try {
          await fetch(
            `/ifc_ai_prediction/api/mapping/${currentMappingId}/save-result/`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                input_values: inputValues,
                prediction_result: { value: prediction },
                prediction_range: errorRange,
                execution_time: 0,
              }),
            }
          );
        } catch (error) {
          console.error("예측 결과 저장 실패:", error);
        }
      }

      // PDF 다운로드 함수
      function downloadPredictionPDF() {
        if (!lastPredictionData || !currentMappingId) {
          alert("예측을 먼저 실행해주세요.");
          return;
        }

        const btn = document.getElementById("downloadPdfBtn");
        const originalHtml = btn.innerHTML;
        btn.innerHTML =
          '<span class="spinner-border spinner-border-sm" role="status"></span> PDF 생성 중...';
        btn.disabled = true;

        try {
          // 차트 이미지를 base64로 추출
          const chartImage = getChartAsImage();

          // 서버에 PDF 생성 요청
          fetch(
            `/ifc_ai_prediction/api/mapping/${currentMappingId}/generate-pdf/1/`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                input_data: lastPredictionData.input_values,
                prediction_result: lastPredictionData.prediction_result,
                prediction_range: lastPredictionData.prediction_range,
                chart_image: chartImage,
              }),
            }
          )
            .then((response) => {
              if (!response.ok) {
                throw new Error("PDF 생성 실패");
              }
              return response.blob();
            })
            .then((blob) => {
              // 파일 다운로드
              const url = URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = url;
              a.download = `ifc_ai_prediction_${new Date()
                .toISOString()
                .slice(0, 10)}.pdf`;
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
            })
            .catch((error) => {
              console.error("PDF 다운로드 오류:", error);
              alert("PDF 다운로드 중 오류가 발생했습니다.");
            })
            .finally(() => {
              btn.innerHTML = originalHtml;
              btn.disabled = false;
            });
        } catch (error) {
          console.error("PDF 처리 오류:", error);
          alert("PDF 처리 중 오류가 발생했습니다.");
          btn.innerHTML = originalHtml;
          btn.disabled = false;
        }
      }

      // 차트를 base64 이미지로 변환
      function getChartAsImage() {
        try {
          const canvas = document.getElementById("resultCanvas");
          if (!canvas) return "";
          return canvas.toDataURL("image/png");
        } catch (error) {
          console.error("차트 이미지 변환 오류:", error);
          return "";
        }
      }

      /* =================== 그룹 콤보박스 =================== */
      function updateGroupComboBoxes() {
        for (let i = 1; i <= 3; i++) {
          const combo = document.getElementById("groupBy" + i);
          const currentValue = combo.value;
          combo.innerHTML = `<option value="">${i}차 그룹: 없음</option>`;

          headers.sort().forEach((header) => {
            const option = document.createElement("option");
            option.value = header;
            option.textContent = header;
            combo.appendChild(option);
          });

          if (currentValue && headers.includes(currentValue)) {
            combo.value = currentValue;
          }
        }
      }

      /* =================== 그룹 테이블 렌더 =================== */
      function updateGroupedTable() {
        const tableHeaders = document.getElementById("tableHeaders");
        const tableBody = document.getElementById("tableBody");

        // 맵 초기화
        guidToRow.clear();

        // 보여줄 주요 헤더
        const mainHeaders = [
          "GlobalId",
          "Name",
          "IfcClass",
          "SpatialContainer",
        ];
        const visibleHeaders = headers
          .filter(
            (h) =>
              mainHeaders.includes(h) ||
              ["Area", "Volume", "Length", "Height", "Width"].some((qty) =>
                h.includes(qty)
              )
          )
          .slice(0, 8);

        tableHeaders.innerHTML = visibleHeaders
          .map((h) => `<th>${h}</th>`)
          .join("");

        // 그룹 키
        const groupKeys = [];
        for (let i = 1; i <= 3; i++) {
          const v = document.getElementById("groupBy" + i).value;
          if (v) groupKeys.push(v);
        }

        tableBody.innerHTML = "";
        let rowCounter = 0; // 각 object-row에 idx 부여

        if (groupKeys.length === 0) {
          objectData.forEach((obj) => {
            const row = createObjectRow(obj, visibleHeaders, rowCounter++);
            tableBody.appendChild(row);
          });
        } else {
          const groupedData = groupObjectsByKeys(objectData, groupKeys);
          renderGroupedData(
            tableBody,
            groupedData,
            0,
            groupKeys,
            visibleHeaders,
            rowCounter
          );
        }

        applyTableSelectionStyles(); // 렌더 후 반영
      }

      function groupObjectsByKeys(objects, keys, depth = 0) {
        if (depth >= keys.length) return objects;

        const grouped = {};
        const key = keys[depth];

        objects.forEach((obj) => {
          let value = obj[key] || "N/A";
          if (!grouped[value]) grouped[value] = [];
          grouped[value].push(obj);
        });

        Object.keys(grouped).forEach((k) => {
          grouped[k] = groupObjectsByKeys(grouped[k], keys, depth + 1);
        });

        return grouped;
      }

      /* =================== AI 모델 로드/정보 =================== */
      function loadModelInfo() {
        const modelId = document.getElementById("aiModelSelect").value;

        if (!modelId) {
          document.getElementById("modelInfo").classList.add("hidden");
          document
            .getElementById("inputMappingSection")
            .classList.add("hidden");
          return;
        }

        fetch(`/ifc_ai_prediction/api/model/${modelId}/metadata/`)
          .then((response) => response.json())
          .then((data) => {
            selectedModel = data;
            displayModelInfo(data);
            loadAIModel(data);
            createInputMappingUI(data);
          })
          .catch((error) => {
            console.error("모델 정보 로드 실패:", error);
            alert("모델 정보를 로드할 수 없습니다.");
          });
      }

      async function loadAIModel(modelMetadata) {
        try {
          const modelResponse = await fetch(modelMetadata.model_file_url);
          const zipBlob = await modelResponse.blob();

          const zip = new JSZip();
          const zipContent = await zip.loadAsync(zipBlob);

          const modelJson = await zipContent.file("model.json").async("string");
          const modelTopology = JSON.parse(modelJson);

          const weightsData = await zipContent
            .file("weights.bin")
            .async("uint8array");

          loadedAIModel = await tf.loadLayersModel(
            tf.io.fromMemory(modelTopology, weightsData)
          );

          console.log("✅ AI 모델 로드 완료");
          updatePredictButton();
        } catch (error) {
          console.error("❌ AI 모델 로드 실패:", error);
          alert("AI 모델을 로드할 수 없습니다: " + error.message);
        }
      }

      function displayModelInfo(model) {
        const details = `
    <div style="background: #f8f9fa; padding: 12px; border-radius: 4px; font-size: 13px;">
      <strong>설명:</strong> ${model.description || "없음"}<br>
      <strong>입력 변수:</strong> ${model.input_columns.join(", ")}<br>
      <strong>출력 변수:</strong> ${model.output_columns.join(", ")}<br>
      ${model.rmse ? `<strong>RMSE:</strong> ${model.rmse.toFixed(4)}<br>` : ""}
      ${model.mae ? `<strong>MAE:</strong> ${model.mae.toFixed(4)}<br>` : ""}
      ${
        model.r2_score
          ? `<strong>R² 점수:</strong> ${model.r2_score.toFixed(4)}`
          : ""
      }
    </div>
  `;
        document.getElementById("modelDetails").innerHTML = details;
        document.getElementById("modelInfo").classList.remove("hidden");
      }

      /* =================== 입력 매핑 UI =================== */
      function createInputMappingUI(model) {
        const container = document.getElementById("inputMappingContainer");
        container.innerHTML = "";
        inputMappings = {};

        model.input_columns.forEach((column, index) => {
          const inputDiv = document.createElement("div");
          inputDiv.className = "input-item";
          inputDiv.innerHTML = `
      <div class="input-header">${column}</div>

      <div class="mapping-type-selector">
        <label><input type="radio" name="type_${index}" value="manual" checked> 직접 입력</label>
        <label><input type="radio" name="type_${index}" value="ifc_aggregation"> IFC 객체 집계</label>
      </div>

      <div class="manual-input-container">
        <input type="number" class="manual-input" data-column="${column}" placeholder="값을 입력하세요" step="any">
      </div>

      <div class="ifc-aggregation-container hidden">
        <div class="filter-conditions" data-column="${column}"></div>
        <button type="button" class="btn-small btn-add" onclick="addFilterCondition('${column}')">+ 조건 추가</button>

        <div class="aggregation-controls">
          <div class="aggregation-row">
            <select class="aggregation-attribute" data-column="${column}">
              <option value="">집계할 속성 선택</option>
              ${headers
                .map((h) => `<option value="${h}">${h}</option>`)
                .join("")}
            </select>
            <select class="aggregation-function" data-column="${column}">
              <option value="sum">합계</option>
              <option value="count">개수</option>
              <option value="avg">평균</option>
              <option value="min">최솟값</option>
              <option value="max">최댓값</option>
            </select>
            <button type="button" class="btn-small btn-test" onclick="testAggregation('${column}')">테스트</button>
          </div>
          <div class="aggregation-result hidden" data-column="${column}"></div>
        </div>
      </div>
    `;
          container.appendChild(inputDiv);

          // 라디오 버튼 변경
          inputDiv
            .querySelectorAll(`input[name="type_${index}"]`)
            .forEach((radio) => {
              radio.addEventListener("change", function () {
                const manualContainer = inputDiv.querySelector(
                  ".manual-input-container"
                );
                const ifcContainer = inputDiv.querySelector(
                  ".ifc-aggregation-container"
                );

                if (this.value === "manual") {
                  manualContainer.classList.remove("hidden");
                  ifcContainer.classList.add("hidden");
                } else {
                  manualContainer.classList.add("hidden");
                  ifcContainer.classList.remove("hidden");
                }
                updateInputMapping(column);
              });
            });

          // 직접 입력
          inputDiv
            .querySelector(".manual-input")
            .addEventListener("input", function () {
              updateInputMapping(column);
            });

          // 집계 설정
          inputDiv
            .querySelector(".aggregation-attribute")
            .addEventListener("change", function () {
              updateInputMapping(column);
            });
          inputDiv
            .querySelector(".aggregation-function")
            .addEventListener("change", function () {
              updateInputMapping(column);
            });

          // 초기 설정
          updateInputMapping(column);
        });

        document
          .getElementById("inputMappingSection")
          .classList.remove("hidden");
        updatePredictButton();
      }

      function updateInputMapping(column) {
        const inputDiv = document
          .querySelector(`[data-column="${column}"]`)
          .closest(".input-item");
        const type = inputDiv.querySelector(
          'input[name^="type_"]:checked'
        ).value;

        if (type === "manual") {
          const value = inputDiv.querySelector(".manual-input").value;
          inputMappings[column] = { type: "manual", value: value || 0 };
        } else {
          const attribute = inputDiv.querySelector(
            ".aggregation-attribute"
          ).value;
          const func = inputDiv.querySelector(".aggregation-function").value;

          inputMappings[column] = {
            type: "ifc_aggregation",
            aggregation_attribute: attribute,
            aggregation_function: func,
            filters: [],
          };
        }

        updatePredictButton();
      }

      /* =================== 필터 조건 =================== */
      function addFilterCondition(column) {
        const container = document.querySelector(
          `.filter-conditions[data-column="${column}"]`
        );
        const conditionDiv = document.createElement("div");
        conditionDiv.className = "filter-condition";

        const conditionCount = container.children.length;
        const relationHtml =
          conditionCount > 0
            ? `<select class="relation-select"><option value="and">그리고</option><option value="or">또는</option></select>`
            : "";

        conditionDiv.innerHTML = `
    ${relationHtml}
    <div class="filter-row">
      <select class="attribute-select">
        <option value="">속성 선택</option>
        ${headers.map((h) => `<option value="${h}">${h}</option>`).join("")}
      </select>
      <input type="text" class="value-input" placeholder="속성값">
      <select class="condition-select">
        <option value="equals">같음</option>
        <option value="contains">포함</option>
        <option value="starts_with">시작함</option>
        <option value="ends_with">끝남</option>
        <option value="greater_than">보다 큼</option>
        <option value="less_than">보다 작음</option>
        <option value="greater_equal">크거나 같음</option>
        <option value="less_equal">작거나 같음</option>
      </select>
      <button type="button" class="btn-small btn-remove" onclick="removeFilterCondition(this)">-</button>
    </div>
  `;

        container.appendChild(conditionDiv);
      }

      function removeFilterCondition(button) {
        button.closest(".filter-condition").remove();
      }

      /* =================== 집계 테스트 =================== */
      function testAggregation(column) {
        const inputDiv = document
          .querySelector(`[data-column="${column}"]`)
          .closest(".input-item");
        const attribute = inputDiv.querySelector(
          ".aggregation-attribute"
        ).value;
        const func = inputDiv.querySelector(".aggregation-function").value;

        if (!attribute) {
          alert("집계할 속성을 선택하세요.");
          return;
        }

        const conditions = [];
        const filterContainer = inputDiv.querySelector(".filter-conditions");

        filterContainer
          .querySelectorAll(".filter-condition")
          .forEach((condition, index) => {
            const attrSelect = condition.querySelector(".attribute-select");
            const condSelect = condition.querySelector(".condition-select");
            const valueInput = condition.querySelector(".value-input");
            const relationSelect = condition.querySelector(".relation-select");

            if (attrSelect.value && condSelect.value && valueInput.value) {
              conditions.push({
                attribute_name: attrSelect.value,
                condition: condSelect.value,
                value: valueInput.value,
                relation: index > 0 ? relationSelect.value : "and",
              });
            }
          });

        // 필터 저장
        fetch("/ifc_ai_prediction/api/filters/save/", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            session_key: sessionKey,
            conditions: conditions,
          }),
        })
          .then((response) => response.json())
          .then((data) => {
            sessionKey = data.session_key;

            return fetch(
              `/ifc_ai_prediction/api/project/${PROJECT_ID}/test-aggregation/`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  filter_session_key: sessionKey,
                  aggregation_attribute: attribute,
                  aggregation_function: func,
                }),
              }
            );
          })
          .then((response) => response.json())
          .then((data) => {
            if (data.success) {
              const resultDiv = inputDiv.querySelector(
                `.aggregation-result[data-column="${column}"]`
              );
              resultDiv.innerHTML = `
          <strong>결과:</strong> ${data.result.toLocaleString("ko-KR", {
            maximumFractionDigits: 2,
          })}<br>
          <small>필터링된 객체: ${data.filtered_count}개, 집계된 값: ${
                data.values_count
              }개</small>
        `;
              resultDiv.classList.remove("hidden");
            } else {
              alert("집계 테스트 실패: " + data.error);
            }
          })
          .catch((error) => {
            console.error("집계 테스트 실패:", error);
            alert("집계 테스트 중 오류가 발생했습니다.");
          });
      }

      /* =================== 예측 =================== */
      function updatePredictButton() {
        const btn = document.getElementById("predictBtn");
        const allInputsValid =
          Object.keys(inputMappings).length ===
          (selectedModel?.input_columns.length || 0);
        btn.disabled = !allInputsValid || !loadedAIModel;
      }

      function executePrediction() {
        if (!selectedModel || !loadedAIModel) {
          alert("AI 모델을 선택하고 로드를 완료하세요.");
          return;
        }

        const btn = document.getElementById("predictBtn");
        btn.disabled = true;
        btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 예측 중...';

        fetch(
          `/ifc_ai_prediction/api/project/${PROJECT_ID}/execute-prediction/`,
          {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              ai_model_id: selectedModel.id,
              input_mappings: inputMappings,
            }),
          }
        )
          .then((response) => response.json())
          .then((data) => {
            if (data.success) {
              currentMappingId = data.mapping_id;
              performPrediction(data.input_values, data.execution_time);
            } else {
              throw new Error(data.error);
            }
          })
          .catch((error) => {
            console.error("예측 실행 실패:", error);
            alert("예측 실행 중 오류가 발생했습니다: " + error.message);

            btn.disabled = false;
            btn.innerHTML = '<i class="fas fa-brain"></i> 예측 실행';
          });
      }

      async function performPrediction(inputValues, executionTime) {
        try {
          const inputArray = selectedModel.input_columns.map(
            (col) => inputValues[col] || 0
          );
          const inputTensor = tf.tensor2d([inputArray]);

          const prediction = await loadedAIModel.predict(inputTensor);
          const predictionArray = await prediction.data();
          const predictionValue = predictionArray[0];

          const errorRange = calculateErrorRange(predictionValue);

          displayPredictionResult(
            predictionValue,
            errorRange,
            inputValues,
            executionTime
          );
          await savePrediction(inputValues, predictionValue, errorRange);

          inputTensor.dispose();
          prediction.dispose();
        } catch (error) {
          console.error("예측 수행 실패:", error);
          alert("예측 수행 중 오류가 발생했습니다: " + error.message);
        } finally {
          const btn = document.getElementById("predictBtn");
          btn.disabled = false;
          btn.innerHTML = '<i class="fas fa-brain"></i> 예측 실행';
        }
      }

      function calculateErrorRange(prediction) {
        const rmse = selectedModel.rmse || 0;
        const errorMargin = rmse * 1.5;

        return {
          min: Math.max(0, prediction - errorMargin),
          max: prediction + errorMargin,
          confidence: Math.max(0, Math.min(1, 1 - rmse / (prediction || 1e-9))),
        };
      }

      function displayPredictionResult(
        prediction,
        errorRange,
        inputValues,
        executionTime
      ) {
        const resultContent = document.getElementById("resultContent");

        lastPredictionData = {
          input_values: inputValues,
          prediction_result: { value: prediction },
          prediction_range: errorRange,
        };

        resultContent.innerHTML = `
    <div class="prediction-result">
      <h5 style="margin-bottom: 15px; color: #0c5460;">
        <i class="fas fa-chart-line"></i> 예측 결과
      </h5>

      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
        <div>
          <strong>예측값:</strong><br>
          <span style="font-size: 1.4em; color: #28a745;">
            ${prediction.toLocaleString("ko-KR", { maximumFractionDigits: 2 })}
          </span>
        </div>
        <div>
          <strong>신뢰도:</strong><br>
          <span style="font-size: 1.4em; color: #17a2b8;">
            ${(errorRange.confidence * 100).toFixed(1)}%
          </span>
        </div>
      </div>

      <div style="background: rgba(255,255,255,0.7); padding: 10px; border-radius: 4px;">
        <strong>예측 범위:</strong><br>
        최솟값: ${errorRange.min.toLocaleString("ko-KR", {
          maximumFractionDigits: 2,
        })}<br>
        최댓값: ${errorRange.max.toLocaleString("ko-KR", {
          maximumFractionDigits: 2,
        })}<br>
        오차 범위: ±${((errorRange.max - errorRange.min) / 2).toLocaleString(
          "ko-KR",
          { maximumFractionDigits: 2 }
        )}
      </div>
    </div>

    <div style="margin-top: 15px;">
      <h6>입력값 요약</h6>
      <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; font-size: 13px;">
        ${Object.entries(inputValues)
          .map(
            ([key, value]) =>
              `<div>${key}: ${value.toLocaleString("ko-KR", {
                maximumFractionDigits: 2,
              })}</div>`
          )
          .join("")}
      </div>
    </div>
  `;

        document.getElementById("predictionResult").classList.remove("hidden");
        createResultChart(prediction, errorRange);
      }

      function createResultChart(result, range) {
        const chartContainer = document.getElementById("resultChart");
        chartContainer.innerHTML =
          '<canvas id="resultCanvas" width="300" height="200"></canvas>';

        const ctx = document.getElementById("resultCanvas").getContext("2d");

        new Chart(ctx, {
          type: "bar",
          data: {
            labels: ["최솟값", "예측값", "최댓값"],
            datasets: [
              {
                label: "예측 결과",
                data: [range.min, result, range.max],
                backgroundColor: [
                  "rgba(255, 193, 7, 0.8)",
                  "rgba(40, 167, 69, 0.8)",
                  "rgba(220, 53, 69, 0.8)",
                ],
                borderColor: [
                  "rgba(255, 193, 7, 1)",
                  "rgba(40, 167, 69, 1)",
                  "rgba(220, 53, 69, 1)",
                ],
                borderWidth: 2,
              },
            ],
          },
          options: {
            responsive: true,
            scales: { y: { beginAtZero: false } },
            plugins: { legend: { display: false } },
          },
        });
      }

      async function savePrediction(inputValues, prediction, errorRange) {
        if (!currentMappingId) return;

        try {
          await fetch(
            `/ifc_ai_prediction/api/mapping/${currentMappingId}/save-result/`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                input_values: inputValues,
                prediction_result: { value: prediction },
                prediction_range: errorRange,
                execution_time: 0,
              }),
            }
          );
        } catch (error) {
          console.error("예측 결과 저장 실패:", error);
        }
      }

      /* =================== PDF 다운로드 =================== */
      function downloadPredictionPDF() {
        if (!lastPredictionData || !currentMappingId) {
          alert("예측을 먼저 실행해주세요.");
          return;
        }

        const btn = document.getElementById("downloadPdfBtn");
        const originalHtml = btn.innerHTML;
        btn.innerHTML =
          '<span class="spinner-border spinner-border-sm" role="status"></span> PDF 생성 중...';
        btn.disabled = true;

        try {
          const chartImage = getChartAsImage();

          fetch(
            `/ifc_ai_prediction/api/mapping/${currentMappingId}/generate-pdf/1/`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                input_data: lastPredictionData.input_values,
                prediction_result: lastPredictionData.prediction_result,
                prediction_range: lastPredictionData.prediction_range,
                chart_image: chartImage,
              }),
            }
          )
            .then((response) => {
              if (!response.ok) throw new Error("PDF 생성 실패");
              return response.blob();
            })
            .then((blob) => {
              const url = URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = url;
              a.download = `ifc_ai_prediction_${new Date()
                .toISOString()
                .slice(0, 10)}.pdf`;
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
            })
            .catch((error) => {
              console.error("PDF 다운로드 오류:", error);
              alert("PDF 다운로드 중 오류가 발생했습니다.");
            })
            .finally(() => {
              btn.innerHTML = originalHtml;
              btn.disabled = false;
            });
        } catch (error) {
          console.error("PDF 처리 오류:", error);
          alert("PDF 처리 중 오류가 발생했습니다.");
          btn.innerHTML = originalHtml;
          btn.disabled = false;
        }
      }

      function getChartAsImage() {
        try {
          const canvas = document.getElementById("resultCanvas");
          if (!canvas) return "";
          return canvas.toDataURL("image/png");
        } catch (error) {
          console.error("차트 이미지 변환 오류:", error);
          return "";
        }
      }
    </script>

    <!-- =========================================
     2) 3D Viewer (three.js + IfcOpenShell WASM)
========================================= -->
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

      /* ===================== 유틸: 옛 스피너 제거 ===================== */
      function hideLegacySpinners() {
        document
          .querySelectorAll("#viewer-loading")
          .forEach((el) => el.remove());
      }

      /* ===================== IFCViewer3D 클래스 ===================== */
      class IFCViewer3D {
        constructor(containerId) {
          this.container = document.getElementById(containerId);
          this.loadingElement = null;
          this.scene = null;
          this.camera = null;
          this.renderer = null;
          this.controls = null;
          this.modelGroup = null;
          this.isInitialized = false;
          //
          this.guidToObject = new Map(); // ★ 추가
          this.onObjectSelected = null; // ★ 추가 (외부에 selection 전달 콜백)
          // 선택 관련
          this.raycaster = new THREE.Raycaster();
          this.mouse = new THREE.Vector2();
          this.selectedObject = null;
          this.originalMaterial = null;
          this.highlightMaterial = null;
          this.isDragging = false;
          this.selectedGuids = new Set(); // 현재 선택된 GUID들
          this.selectionMap = new Map(); // guid -> {object, material}

          this.init();
        }

        init() {
          // 씬
          this.scene = new THREE.Scene();
          this.scene.background = new THREE.Color(0xf5f5f5);

          // 카메라
          const aspect =
            this.container.clientWidth / this.container.clientHeight;
          this.camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 5000);
          this.camera.position.set(30, 25, 30);

          // 렌더러
          this.renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: false,
            powerPreference: "high-performance",
          });
          this.renderer.setSize(
            this.container.clientWidth,
            this.container.clientHeight
          );
          this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          this.renderer.shadowMap.enabled = true;
          this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          this.renderer.outputColorSpace = THREE.SRGBColorSpace;
          this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
          this.renderer.toneMappingExposure = 1.0;
          this.container.appendChild(this.renderer.domElement);

          // 모델 그룹
          this.modelGroup = new THREE.Group();
          this.scene.add(this.modelGroup);

          // 하이라이트 재질
          this.highlightMaterial = new THREE.MeshLambertMaterial({
            color: 0xff6b35,
            transparent: true,
            opacity: 0.9,
            side: THREE.DoubleSide,
          });

          // 조명, 컨트롤, 이벤트
          this.setupLighting();
          this.setupControls();
          this.setupEventListeners();

          // 루프
          this.animate();

          this.isInitialized = true;
          console.log("✅ 3D 뷰어 초기화 완료");
        }
        setSelection(guidsArray) {
          const newSet = new Set(guidsArray);

          // 해제해야 할 것들
          this.selectedGuids.forEach((g) => {
            if (!newSet.has(g)) this._unhighlightByGuid(g);
          });

          // 새로 하이라이트할 것들
          newSet.forEach((g) => {
            if (!this.selectedGuids.has(g)) this._highlightByGuid(g);
          });

          this.selectedGuids = newSet;

          // 콜백 (뷰어 -> 테이블 동기화)
          if (typeof this.onSelectionChange === "function") {
            this.onSelectionChange(Array.from(this.selectedGuids));
          }
        }

        _updateSelectionFromClick(guid, additive) {
          let newSet = new Set(this.selectedGuids);
          if (additive) {
            if (newSet.has(guid)) newSet.delete(guid);
            else newSet.add(guid);
          } else {
            newSet = new Set([guid]);
          }
          this.setSelection(Array.from(newSet));
        }

        _highlightByGuid(guid) {
          const obj = this.guidToObject.get(guid);
          if (!obj) return;
          let mesh = obj;
          if (obj.type === "Group" && obj.children.length > 0)
            mesh = obj.children[0];

          const originalMaterial = mesh.material;
          mesh.material = this.highlightMaterial;

          this.selectionMap.set(guid, {
            object: obj,
            material: originalMaterial,
          });
        }

        _unhighlightByGuid(guid) {
          const entry = this.selectionMap.get(guid);
          if (!entry) return;
          let mesh = entry.object;
          if (mesh.type === "Group" && mesh.children.length > 0)
            mesh = mesh.children[0];
          mesh.material = entry.material;
          this.selectionMap.delete(guid);
        }

        clearSelection() {
          this.setSelection([]);
        }

        showLoading(show, message = "모델 로딩중...") {
          if (show) {
            if (!this.loadingElement) {
              this.loadingElement = document.createElement("div");
              this.loadingElement.id = "ifc-viewer-loading";
              this.loadingElement.style.cssText = `
          position: absolute; top:50%; left:50%; transform:translate(-50%,-50%);
          z-index:1000; text-align:center; background:rgba(255,255,255,0.9);
          padding:20px; border-radius:8px; box-shadow:0 4px 8px rgba(0,0,0,0.1);
          font-family: Arial, sans-serif;
        `;
              this.loadingElement.innerHTML = `
          <div style="width:40px;height:40px;border:4px solid #f3f3f3;border-top:4px solid #667eea;border-radius:50%;animation:spin 1s linear infinite;margin:0 auto 10px;"></div>
          <div style="color:#495057;font-weight:600;" id="loading-text">${message}</div>
          <style>
            @keyframes spin { 0%{transform:rotate(0deg);}100%{transform:rotate(360deg);} }
          </style>
        `;
              this.container.appendChild(this.loadingElement);
            } else {
              this.loadingElement.querySelector("#loading-text").textContent =
                message;
              this.loadingElement.style.display = "block";
            }
          } else {
            if (this.loadingElement) this.loadingElement.style.display = "none";
            hideLegacySpinners(); // 혹시 남아있는 구버전 스피너 제거
          }
        }

        setupLighting() {
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
          this.scene.add(ambientLight);

          const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
          directionalLight.position.set(50, 50, 25);
          directionalLight.castShadow = true;
          directionalLight.shadow.mapSize.width = 2048;
          directionalLight.shadow.mapSize.height = 2048;
          directionalLight.shadow.camera.near = 0.5;
          directionalLight.shadow.camera.far = 200;
          directionalLight.shadow.camera.left = -50;
          directionalLight.shadow.camera.right = 50;
          directionalLight.shadow.camera.top = 50;
          directionalLight.shadow.camera.bottom = -50;
          this.scene.add(directionalLight);

          const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
          fillLight.position.set(-25, 20, -25);
          this.scene.add(fillLight);

          const rimLight = new THREE.DirectionalLight(0xffffff, 0.3);
          rimLight.position.set(0, 10, -50);
          this.scene.add(rimLight);
        }

        setupControls() {
          this.controls = new OrbitControls(
            this.camera,
            this.renderer.domElement
          );

          this.controls.enableDamping = true;
          this.controls.dampingFactor = 0.08;
          this.controls.screenSpacePanning = false;

          // 회전
          this.controls.enableRotate = true;
          this.controls.rotateSpeed = 0.6;
          this.controls.minPolarAngle = 0.1;
          this.controls.maxPolarAngle = Math.PI - 0.1;

          // 줌은 직접 구현
          this.controls.enableZoom = false;
          this.controls.minDistance = 5;
          this.controls.maxDistance = 500;

          // 팬
          this.controls.enablePan = true;
          this.controls.panSpeed = 0.8;
          this.controls.keyPanSpeed = 15.0;

          this.controls.mouseButtons = {
            LEFT: THREE.MOUSE.ROTATE,
            MIDDLE: THREE.MOUSE.DOLLY,
            RIGHT: THREE.MOUSE.PAN,
          };
          this.controls.touches = {
            ONE: THREE.TOUCH.ROTATE,
            TWO: THREE.TOUCH.DOLLY_PAN,
          };
          this.controls.autoRotate = false;
          this.controls.autoRotateSpeed = 1.0;
        }

        setupEventListeners() {
          window.addEventListener("resize", () => this.handleResize());
          this.container.addEventListener("contextmenu", (e) =>
            e.preventDefault()
          );
          this.renderer.domElement.addEventListener("click", () => {
            this.renderer.domElement.focus();
          });
          this.renderer.domElement.tabIndex = 0;

          this.renderer.domElement.addEventListener("mousedown", (e) =>
            this.onMouseDown(e)
          );
          this.renderer.domElement.addEventListener("mousemove", (e) =>
            this.onMouseMove(e)
          );
          this.renderer.domElement.addEventListener("mouseup", (e) =>
            this.onMouseUp(e)
          );
          this.renderer.domElement.addEventListener("click", (e) =>
            this.onMouseClick(e)
          );
          this.renderer.domElement.addEventListener("wheel", (e) =>
            this.onMouseWheel(e)
          );

          window.addEventListener("keydown", (event) => {
            if (event.code === "Escape") this.clearSelection();
          });
        }

        handleResize() {
          const width = this.container.clientWidth;
          const height = this.container.clientHeight;
          this.camera.aspect = width / height;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(width, height);
          this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        }

        animate() {
          requestAnimationFrame(() => this.animate());
          if (this.controls) this.controls.update();
          if (this.renderer && this.scene && this.camera) {
            this.renderer.render(this.scene, this.camera);
          }
        }

        // IFCViewer3D 클래스 내부의 기존 onMouseWheel(event) 를 전부 이걸로 교체
        onMouseWheel(event) {
          event.preventDefault();

          // 줌 배율 (휠 한 번당 10% 정도)
          const zoomScale = event.deltaY > 0 ? 1.1 : 0.9;

          // 현재 마우스 위치를 정규화 좌표로 갱신
          this.updateMousePosition(event);

          // 레이캐스트로 마우스가 가리키는 3D 위치 계산
          this.raycaster.setFromCamera(this.mouse, this.camera);
          const intersects = this.raycaster.intersectObjects(
            this.modelGroup.children,
            true
          );

          // 교차 지점이 있으면 거기를 기준점으로, 없으면 카메라 타깃(controls.target)을 기준으로 사용
          const pivot =
            intersects.length > 0
              ? intersects[0].point.clone()
              : this.controls.target.clone();

          // 카메라 위치를 pivot을 기준으로 스케일링
          const camToPivot = new THREE.Vector3().subVectors(
            this.camera.position,
            pivot
          );
          camToPivot.multiplyScalar(zoomScale);
          const newCamPos = new THREE.Vector3().addVectors(pivot, camToPivot);

          // 거리 제한(OrbitControls의 min/maxDistance 준수)
          const distToTarget = newCamPos.distanceTo(this.controls.target);
          const clampedDist = THREE.MathUtils.clamp(
            distToTarget,
            this.controls.minDistance,
            this.controls.maxDistance
          );

          // 만약 제한에 걸린다면 방향은 유지하고 거리만 보정
          if (distToTarget !== clampedDist) {
            const dir = new THREE.Vector3()
              .subVectors(newCamPos, this.controls.target)
              .normalize();
            newCamPos
              .copy(this.controls.target)
              .add(dir.multiplyScalar(clampedDist));
          }

          // 카메라 이동
          this.camera.position.copy(newCamPos);

          // 회전 중심(controls.target)은 건드리지 않으므로 화면 회전 중심은 기존 그대로 유지됩니다.
          this.controls.update();
        }

        onMouseDown(event) {
          this.isDragging = false;
          this.updateMousePosition(event);
        }

        onMouseMove(event) {
          if (event.buttons > 0) this.isDragging = true;
          this.updateMousePosition(event);
        }

        onMouseUp() {
          if (this.isDragging) {
            this.isDragging = false;
            return;
          }
        }

        updateMousePosition(event) {
          const rect = this.renderer.domElement.getBoundingClientRect();
          this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }

        onMouseClick(event) {
          if (this.isDragging || event.button !== 0) return;

          this.updateMousePosition(event);
          this.raycaster.setFromCamera(this.mouse, this.camera);

          const hits = this.raycaster.intersectObjects(
            this.modelGroup.children,
            true
          );
          const hit = hits.find((h) => h.object.type !== "LineSegments");

          const additive = event.ctrlKey || event.metaKey || event.shiftKey;

          if (!hit) {
            // 배경 클릭 시: 추가 선택 모드가 아니면 전체 해제
            if (!additive) this.clearSelection();
            return;
          }

          let targetGroup = hit.object;
          while (targetGroup.parent && targetGroup.parent !== this.modelGroup) {
            targetGroup = targetGroup.parent;
          }

          const guid =
            targetGroup?.userData?.ifcGuid ||
            targetGroup?.userData?.GlobalId ||
            targetGroup?.userData?.globalId;

          if (!guid) return;

          this._updateSelectionFromClick(guid, additive);
        }

        selectByGuid(guid, additive = false) {
          const set = new Set(this.selectedGuids);
          if (additive) set.add(guid);
          else {
            set.clear();
            set.add(guid);
          }
          this.setSelection(Array.from(set));
        }

        clearSelection() {
          this.setSelection([]);
        }

        addModelWithEdges(geometry, originalMaterial, userData) {
          const grayColor = new THREE.Color(0.502, 0.502, 0.502);

          let finalMaterial;
          if (
            originalMaterial &&
            originalMaterial.color &&
            !originalMaterial.color.equals(new THREE.Color(1, 1, 1)) &&
            !originalMaterial.color.equals(new THREE.Color(0, 0, 0))
          ) {
            finalMaterial = originalMaterial.clone();
          } else {
            finalMaterial = new THREE.MeshLambertMaterial({
              color: grayColor,
              side: THREE.DoubleSide,
              transparent: originalMaterial
                ? originalMaterial.transparent
                : false,
              opacity: originalMaterial ? originalMaterial.opacity : 1.0,
            });
          }

          const mesh = new THREE.Mesh(geometry, finalMaterial);
          mesh.userData = userData;
          mesh.castShadow = true;
          mesh.receiveShadow = true;

          const edges = new THREE.EdgesGeometry(geometry);
          const edgeMaterial = new THREE.LineBasicMaterial({
            color: 0x000000,
            transparent: true,
            opacity: 0.4,
            linewidth: 1,
          });
          const wireframe = new THREE.LineSegments(edges, edgeMaterial);
          wireframe.userData = userData;

          const group = new THREE.Group();
          group.add(mesh);
          group.add(wireframe);
          group.userData = userData;

          return group;
        }

        addModel(object) {
          this.modelGroup.add(object);

          // ★ IFC GUID 등록
          const guid =
            object?.userData?.ifcGuid ||
            object?.userData?.GlobalId ||
            object?.userData?.globalId ||
            null;
          if (guid) this.guidToObject.set(guid, object);
        }

        clearModels() {
          this.clearSelection();
          if (this.modelGroup) {
            while (this.modelGroup.children.length > 0) {
              const child = this.modelGroup.children[0];
              if (child.geometry) child.geometry.dispose();
              if (child.material) {
                if (Array.isArray(child.material))
                  child.material.forEach((mat) => mat.dispose());
                else child.material.dispose();
              }
              this.modelGroup.remove(child);
            }
          }
        }

        fitCameraToModel() {
          if (!this.modelGroup || this.modelGroup.children.length === 0) {
            this.camera.position.set(30, 25, 30);
            this.camera.lookAt(0, 0, 0);
            this.controls.target.set(0, 0, 0);
            this.controls.update();
            return;
          }

          const box = new THREE.Box3().setFromObject(this.modelGroup);
          const center = box.getCenter(new THREE.Vector3());
          const size = box.getSize(new THREE.Vector3());

          const maxDim = Math.max(size.x, size.y, size.z);
          const fov = this.camera.fov * (Math.PI / 180);
          const distance = Math.abs(maxDim / (2 * Math.tan(fov / 2)));
          const finalDistance = distance * 1.5;

          const phi = Math.PI / 6;
          const theta = Math.PI / 4;

          const x = center.x + finalDistance * Math.sin(phi) * Math.cos(theta);
          const y = center.y + finalDistance * Math.cos(phi);
          const z = center.z + finalDistance * Math.sin(phi) * Math.sin(theta);

          this.camera.position.set(x, y, z);
          this.camera.lookAt(center);

          this.controls.target.copy(center);
          this.controls.minDistance = finalDistance * 0.1;
          this.controls.maxDistance = finalDistance * 5;
          this.controls.update();

          console.log("카메라 조정:", {
            center,
            size,
            distance: finalDistance,
            cameraPos: { x, y, z },
          });
        }

        resetView() {
          this.fitCameraToModel();
        }

        toggleAutoRotate() {
          this.controls.autoRotate = !this.controls.autoRotate;
          return this.controls.autoRotate;
        }

        toggleWireframe() {
          this.modelGroup.traverse((child) => {
            if (
              child.type === "Mesh" &&
              child.material &&
              child.material.wireframe !== undefined
            ) {
              child.material.wireframe = !child.material.wireframe;
            }
          });
        }

        getSelectedObject() {
          return this.selectedObject
            ? {
                object: this.selectedObject,
                userData: this.selectedObject.userData,
                target: this.controls.target.clone(),
              }
            : null;
        }
      }

      /* ===================== IFC 로딩 ===================== */
      const viewer = new IFCViewer3D("viewer");
      window.ifcViewer = viewer; // 전역 접근

      viewer.onSelectionChange = (guids) => {
        if (isSyncingFromTable) return; // 테이블에서 트리거된 경우 무시
        isSyncingFromViewer = true;
        selectRowsByGuids(guids);
        isSyncingFromViewer = false;
      };

      const IFC_URL = "{{ ifc_abs_url }}";
      const WHEEL_URL =
        "{% static 'wasm/IfcOpenShell-0.7.0-py3-none-any.whl' %}";

      function showLoadingStatus(message) {
        console.log("🔄 " + message);
        viewer.showLoading(true, message);
      }

      (async () => {
        // 중복 스피너 제거
        hideLegacySpinners();

        try {
          showLoadingStatus("Pyodide 초기화 중...");

          const pyodide = await loadPyodide();
          await pyodide.loadPackage("micropip");
          const micropip = pyodide.pyimport("micropip");

          showLoadingStatus("IfcOpenShell 설치 중...");
          await micropip.install(WHEEL_URL);

          showLoadingStatus("IFC 파일 다운로드 중...");
          const ifcText = await (await fetch(IFC_URL)).text();

          showLoadingStatus("IFC 파일 파싱 중...");
          const ifcopenshell = pyodide.pyimport("ifcopenshell");
          const ifc = ifcopenshell.file.from_string(ifcText);
          const ifcopenshell_geom = pyodide.pyimport("ifcopenshell.geom");

          const settings = ifcopenshell_geom.settings();
          settings.set(settings.WELD_VERTICES, false);

          const iterator = ifcopenshell_geom.iterator(settings, ifc);

          if (iterator.initialize()) {
            showLoadingStatus("3D 지오메트리 생성 중...");

            let geometries = [];
            let lastMeshId = null;
            let processedCount = 0;

            while (true) {
              const obj = iterator.get();
              const elementType = ifc.by_id(obj.id).is_a();

              if (
                elementType !== "IfcOpeningElement" &&
                elementType !== "IfcSpace"
              ) {
                if (lastMeshId !== obj.geometry.id) {
                  geometries = [];

                  const materials = obj.geometry.materials.toJs().map((mat) => {
                    const diffuse = mat.diffuse.toJs();
                    let hasValidColor = false;
                    if (diffuse.length === 3) {
                      const [r, g, b] = diffuse;
                      hasValidColor = !(
                        (r === 1 && g === 1 && b === 1) ||
                        (r === 0 && g === 0 && b === 0)
                      );
                    }

                    return new THREE.MeshLambertMaterial({
                      color: hasValidColor
                        ? new THREE.Color(...diffuse)
                        : new THREE.Color(0.502, 0.502, 0.502),
                      opacity: 1.0 - mat.transparency,
                      transparent: mat.transparency > 1e-5,
                      side: THREE.DoubleSide,
                    });
                  });

                  const mapping = {};
                  obj.geometry.material_ids.toJs().forEach((mid, idx) => {
                    mapping[mid] = mapping[mid] || [];
                    mapping[mid].push(idx);
                  });

                  const vertices = new Float32Array(obj.geometry.verts.toJs());
                  const normals = new Float32Array(obj.geometry.normals.toJs());
                  const faces = obj.geometry.faces.toJs();

                  let offset = 0;
                  if (mapping[-1]) {
                    materials.unshift(
                      new THREE.MeshLambertMaterial({
                        color: new THREE.Color(0.502, 0.502, 0.502),
                        side: THREE.DoubleSide,
                      })
                    );
                    offset = 1;
                  }

                  materials.forEach((material, materialIndex) => {
                    const idxList = mapping[materialIndex - offset];
                    if (!idxList || idxList.length === 0) return;

                    const geometry = new THREE.BufferGeometry();
                    const indices = [];
                    idxList.forEach((i) => {
                      indices.push(
                        faces[3 * i],
                        faces[3 * i + 1],
                        faces[3 * i + 2]
                      );
                    });

                    geometry.setIndex(indices);
                    geometry.setAttribute(
                      "position",
                      new THREE.BufferAttribute(vertices, 3)
                    );
                    geometry.setAttribute(
                      "normal",
                      new THREE.BufferAttribute(normals, 3)
                    );
                    geometry.computeBoundingSphere();

                    geometries.push([geometry, material]);
                  });

                  lastMeshId = obj.geometry.id;
                }

                geometries.forEach(([geometry, material]) => {
                  const userData = {
                    ifcId: obj.id,
                    ifcType: obj.type,
                    ifcGuid: obj.guid || null,
                    elementType: elementType,
                  };

                  const meshGroup = viewer.addModelWithEdges(
                    geometry,
                    material,
                    userData
                  );

                  const transformMatrix = obj.transformation.matrix.data.toJs();
                  const matrix = new THREE.Matrix4()
                    .set(
                      transformMatrix[0],
                      transformMatrix[1],
                      transformMatrix[2],
                      0,
                      transformMatrix[3],
                      transformMatrix[4],
                      transformMatrix[5],
                      0,
                      transformMatrix[6],
                      transformMatrix[7],
                      transformMatrix[8],
                      0,
                      transformMatrix[9],
                      transformMatrix[10],
                      transformMatrix[11],
                      1
                    )
                    .transpose();

                  meshGroup.matrixAutoUpdate = false;
                  meshGroup.matrix.copy(matrix);

                  viewer.addModel(meshGroup);
                });

                processedCount++;
                if (processedCount % 50 === 0) {
                  showLoadingStatus(`처리 중... ${processedCount}개 완료`);
                }
              }

              if (!iterator.next()) break;
            }

            showLoadingStatus(
              `✅ 모델 로딩 완료! 총 ${processedCount}개 객체 처리`
            );

            // Z-up -> Y-up
            viewer.modelGroup.rotation.x = -Math.PI / 2;

            setTimeout(() => {
              viewer.fitCameraToModel();
              viewer.showLoading(false);
            }, 100);
          } else {
            throw new Error("IFC iterator 초기화 실패");
          }
        } catch (error) {
          console.error("❌ IFC 로딩 실패:", error);
          showLoadingStatus("로딩 실패 - 기본 박스 표시");

          const geometry = new THREE.BoxGeometry(5, 5, 5);
          const material = new THREE.MeshLambertMaterial({
            color: new THREE.Color(0.502, 0.502, 0.502),
            side: THREE.DoubleSide,
          });
          const userData = {
            ifcId: "test",
            ifcType: "TestBox",
            elementType: "TestBox",
          };

          const testGroup = viewer.addModelWithEdges(
            geometry,
            material,
            userData
          );
          viewer.addModel(testGroup);
          viewer.fitCameraToModel();
          viewer.showLoading(false);
        } finally {
          hideLegacySpinners();
        }
      })();

      /* ===================== 콘솔 헬퍼 ===================== */
      window.viewerControls = {
        resetView: () => viewer.resetView(),
        toggleAutoRotate: () => viewer.toggleAutoRotate(),
        toggleWireframe: () => viewer.toggleWireframe(),
        clearSelection: () => viewer.clearSelection(),
        getSelectedObject: () => viewer.getSelectedObject(),
        getStats: () => ({
          objects: viewer.modelGroup.children.length,
          triangles: viewer.modelGroup.children.reduce((sum, child) => {
            return (
              sum +
              (child.children?.[0]?.geometry
                ? child.children[0].geometry.index.count / 3
                : 0)
            );
          }, 0),
          selectedObject: viewer.selectedObject
            ? viewer.selectedObject.userData
            : null,
        }),
      };

      console.log("🎮 뷰어 컨트롤:");
      console.log("  viewerControls.resetView()");
      console.log("  viewerControls.toggleAutoRotate()");
      console.log("  viewerControls.toggleWireframe()");
      console.log("  viewerControls.clearSelection()");
      console.log("  viewerControls.getSelectedObject()");
      console.log("  viewerControls.getStats()");
      console.log("");
      console.log("💡 조작법:");
      console.log("  좌클릭: 객체 선택 / ESC: 선택 해제");
      console.log("  마우스 휠: 포인터 기준 줌 (직접 구현)");
      console.log("  드래그: 선택 객체 중심 회전 (카메라는 이동 안 함)");
    </script>

    <!-- Scripts -->
    <script src="{% static 'js/jquery.min.js'%}"></script>
    <script src="{% static 'js/jquery.dropotron.min.js'%}"></script>
    <script src="{% static 'js/browser.min.js'%}"></script>
    <script src="{% static 'js/breakpoints.min.js'%}"></script>
    <script src="{% static 'js/util.js'%}"></script>
    <script src="{% static 'js/main.js'%}"></script>
  </body>
</html>
