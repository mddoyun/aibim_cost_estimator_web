<!--templates/ifc_ai_prediction/prediction.html-->

{% load static %}
<!DOCTYPE html>
<html>
  <head>
    <title>IFC AI 예측 - {{ project.name }}</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, user-scalable=no"
    />

    <!-- three.js / OrbitControls ES module importmap -->
    <script type="importmap">
      {
        "imports": {
          "three": "{% static 'js/three.module.js' %}",
          "three/examples/jsm/controls/OrbitControls.js": "{% static 'js/OrbitControls.js' %}"
        }
      }
    </script>
    <script
      async
      src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
    ></script>

    <!-- Pyodide + IfcOpenShell WASM -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.22.0a1/full/pyodide.js"></script>

    <!-- TensorFlow.js, Chart.js, JSZip -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

    <!-- CSS -->
    <link
      rel="stylesheet"
      href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
    />
    <link rel="stylesheet" href="{% static 'css/main.css' %}" />

    <style>
      body {
        background: #f8f9fa;
        margin: 0;
        padding: 0;
      }

      .nav-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 15px 0;
        margin-bottom: 0;
      }
      .nav-links {
        text-align: center;
      }
      .nav-links a {
        color: white;
        text-decoration: none;
        margin: 0 15px;
        padding: 8px 16px;
        border-radius: 4px;
        transition: background 0.3s ease;
      }
      .nav-links a:hover {
        background: rgba(255, 255, 255, 0.2);
        text-decoration: none;
        color: white;
      }

      .project-info {
        background: white;
        padding: 15px;
        border-bottom: 1px solid #dee2e6;
      }

      .main-container {
        display: grid;
        grid-template-columns: 1fr 400px;
        gap: 20px;
        padding: 20px;
        height: calc(100vh - 180px);
      }

      .left-panel {
        display: grid;
        grid-template-rows: 300px 1fr;
        gap: 20px;
      }

      .viewer-container {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        overflow: hidden;
      }

      #viewer {
        width: 100%;
        height: 100%;
      }

      .objects-container {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        padding: 20px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }

      .objects-header {
        display: flex;
        justify-content: between;
        align-items: center;
        margin-bottom: 15px;
        border-bottom: 1px solid #dee2e6;
        padding-bottom: 10px;
      }

      .group-controls {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
        flex-wrap: wrap;
      }

      .group-controls select {
        flex: 1;
        min-width: 120px;
        padding: 5px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 12px;
      }

      .objects-table-container {
        flex: 1;
        overflow: auto;
        border: 1px solid #dee2e6;
        border-radius: 4px;
      }

      .objects-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 11px;
      }

      .objects-table th,
      .objects-table td {
        padding: 6px 8px;
        border-bottom: 1px solid #dee2e6;
        text-align: left;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 150px;
      }

      .objects-table th {
        background: #f8f9fa;
        font-weight: 600;
        position: sticky;
        top: 0;
        z-index: 10;
      }

      .objects-table tbody tr:hover {
        background: #f0f8ff;
        cursor: pointer;
      }

      .group-header {
        background: #e9ecef !important;
        font-weight: bold;
        cursor: pointer;
      }

      .group-header:hover {
        background: #dee2e6 !important;
      }

      .right-panel {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        padding: 20px;
        overflow-y: auto;
      }

      .section-header {
        font-size: 16px;
        font-weight: 600;
        color: #495057;
        margin-bottom: 15px;
        padding-bottom: 8px;
        border-bottom: 2px solid #667eea;
      }

      .model-selector {
        margin-bottom: 20px;
      }

      .model-selector select {
        width: 100%;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
      }

      .input-mapping-container {
        margin-bottom: 20px;
      }

      .input-item {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 15px;
        margin-bottom: 15px;
      }

      .input-header {
        font-weight: 600;
        color: #495057;
        margin-bottom: 10px;
      }

      .mapping-type-selector {
        margin-bottom: 10px;
      }

      .mapping-type-selector label {
        margin-right: 15px;
        font-weight: normal;
      }

      .manual-input {
        width: 100%;
        padding: 6px;
        border: 1px solid #ddd;
        border-radius: 4px;
      }

      .filter-condition {
        background: #fff;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 10px;
        margin-bottom: 8px;
      }

      .filter-row {
        display: flex;
        gap: 8px;
        align-items: center;
        margin-bottom: 5px;
      }

      .filter-row select,
      .filter-row input {
        flex: 1;
        min-width: 80px;
        padding: 4px;
        border: 1px solid #ddd;
        border-radius: 3px;
        font-size: 11px;
      }

      .btn-small {
        padding: 4px 8px;
        font-size: 11px;
        border: none;
        border-radius: 3px;
        cursor: pointer;
      }

      .btn-add {
        background: #28a745;
        color: white;
      }

      .btn-remove {
        background: #dc3545;
        color: white;
      }

      .btn-test {
        background: #17a2b8;
        color: white;
      }

      .aggregation-controls {
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px solid #ddd;
      }

      .aggregation-row {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .aggregation-result {
        background: #d4edda;
        border: 1px solid #c3e6cb;
        color: #155724;
        padding: 8px;
        border-radius: 4px;
        margin-top: 8px;
        font-weight: 600;
      }

      .btn-predict {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
        width: 100%;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .btn-predict:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
      }

      .btn-predict:disabled {
        background: #6c757d;
        cursor: not-allowed;
      }

      .prediction-result {
        background: #d1ecf1;
        border: 1px solid #bee5eb;
        color: #0c5460;
        padding: 15px;
        border-radius: 6px;
        margin-top: 15px;
      }

      .result-chart {
        margin-top: 15px;
        text-align: center;
      }

      .loading {
        text-align: center;
        padding: 20px;
        color: #6c757d;
      }

      .hidden {
        display: none;
      }
    </style>
  </head>
  <body data-project-id="{{ project.id }}">
    <!-- 네비게이션 헤더 -->
    <!-- Header -->
    <div id="header">
      <!-- Logo -->
      <h1>
        <a href="/" id="logo">AIBIM <em>Cost Estimator</em></a>
      </h1>

      <!-- Nav -->
      <nav id="nav">
        <ul>
          <li><a href="/">홈</a></li>
          <li>
            <a href="#">계획설계단계 견적</a>
            <ul>
              <li>
                <a href="/ai_prediction/">AI 개산견적</a>
              </li>
            </ul>
          </li>
          <li class="current">
            <a href="#">중간설계단계 견적</a>
            <ul>
              <li>
                <a href="/ifc_ai_prediction/">AI+BIM 개산견적(IFC기반)</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#">실시설계단계 견적</a>
            <ul>
              <li>
                <a href="/dd_by_ifc/">AI+BIM 상세견적(IFC기반)</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="/ai_learning">AI모델 학습</a>
          </li>
        </ul>
      </nav>
    </div>

    <!-- 프로젝트 정보 -->
    <div class="project-info">
      <div class="container">
        <h4 style="margin: 0; color: #495057">
          <i class="fas fa-brain"></i>
          {{ project.name }} - AI 예측
        </h4>
        <small class="text-muted">{{ project.description }}</small>
      </div>
    </div>

    <!-- 메인 컨테이너 -->
    <div class="main-container">
      <!-- 좌측 패널 -->
      <div class="left-panel">
        <!-- 3D 뷰어 -->
        <div class="viewer-container">
          <div id="viewer"></div>
        </div>

        <!-- IFC 객체 테이블 -->
        <div class="objects-container">
          <div class="objects-header">
            <h5 style="margin: 0">IFC 객체 정보</h5>
            <span id="objectCount" class="text-muted">로딩 중...</span>
          </div>

          <div class="group-controls">
            <select id="groupBy1">
              <option value="">1차 그룹: 없음</option>
            </select>
            <select id="groupBy2">
              <option value="">2차 그룹: 없음</option>
            </select>
            <select id="groupBy3">
              <option value="">3차 그룹: 없음</option>
            </select>
          </div>

          <div class="objects-table-container">
            <table class="objects-table" id="objectsTable">
              <thead>
                <tr id="tableHeaders">
                  <th>로딩 중...</th>
                </tr>
              </thead>
              <tbody id="tableBody">
                <tr>
                  <td class="loading">
                    <i class="fas fa-spinner fa-spin"></i>
                    IFC 객체 데이터를 로딩하고 있습니다...
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>

      <!-- 우측 패널 (AI 예측 설정) -->
      <div class="right-panel">
        <div class="section-header">AI 모델 선택</div>

        <div class="model-selector">
          <select id="aiModelSelect">
            <option value="">AI 모델을 선택하세요</option>
            {% for model in ai_models %}
            <option value="{{ model.id }}">{{ model.name }}</option>
            {% endfor %}
          </select>
        </div>

        <div id="modelInfo" class="hidden">
          <div class="section-header">모델 정보</div>
          <div id="modelDetails"></div>
        </div>

        <div id="inputMappingSection" class="hidden">
          <div class="section-header">입력 설정</div>
          <div id="inputMappingContainer"></div>

          <button id="predictBtn" class="btn-predict" disabled>
            <i class="fas fa-brain"></i>
            예측 실행
          </button>
        </div>

        <div id="predictionResult" class="hidden">
          <div class="section-header">예측 결과</div>
          <div id="resultContent"></div>
          <div id="resultChart" class="result-chart"></div>

          <button
            id="downloadPdfBtn"
            class="btn btn-success btn-block mt-3"
            onclick="downloadPredictionPDF()"
          >
            <i class="fas fa-file-pdf"></i>
            PDF 다운로드
          </button>
        </div>
      </div>
    </div>

    <!-- Scripts -->
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"></script>
    <script src="https://kit.fontawesome.com/your-fontawesome-kit.js"></script>

    <!-- 메인 스크립트 -->
    <script>
      // 전역 변수
      const PROJECT_ID = parseInt(document.body.dataset.projectId);
      let objectData = [];
      let headers = [];
      let groupedObjects = [];
      let selectedModel = null;
      let sessionKey = null;
      let inputMappings = {};
      let loadedAIModel = null;
      let lastPredictionData = null;
      let currentMappingId = null;

      // 페이지 로딩 시 초기화
      document.addEventListener("DOMContentLoaded", function () {
        loadIFCObjects();
        setupEventHandlers();
      });

      // 이벤트 핸들러 설정
      function setupEventHandlers() {
        // AI 모델 선택
        document
          .getElementById("aiModelSelect")
          .addEventListener("change", loadModelInfo);

        // 그룹 콤보박스
        for (let i = 1; i <= 3; i++) {
          document
            .getElementById("groupBy" + i)
            .addEventListener("change", updateGroupedTable);
        }

        // 예측 실행
        document
          .getElementById("predictBtn")
          .addEventListener("click", executePrediction);
      }

      // IFC 객체 데이터 로드
      function loadIFCObjects() {
        fetch(`/ifc_ai_prediction/api/project/${PROJECT_ID}/objects/`)
          .then((response) => response.json())
          .then((data) => {
            objectData = data.objects;
            headers = data.headers;

            document.getElementById(
              "objectCount"
            ).textContent = `총 ${data.total_count}개 객체`;

            updateGroupComboBoxes();
            updateGroupedTable();
          })
          .catch((error) => {
            console.error("IFC 객체 로드 실패:", error);
            document.getElementById("objectCount").textContent = "로딩 실패";
          });
      }

      // 그룹 콤보박스 업데이트
      function updateGroupComboBoxes() {
        for (let i = 1; i <= 3; i++) {
          const combo = document.getElementById("groupBy" + i);
          const currentValue = combo.value;
          combo.innerHTML = `<option value="">${i}차 그룹: 없음</option>`;

          headers.sort().forEach((header) => {
            const option = document.createElement("option");
            option.value = header;
            option.textContent = header;
            combo.appendChild(option);
          });

          if (currentValue && headers.includes(currentValue)) {
            combo.value = currentValue;
          }
        }
      }

      // 그룹화된 테이블 업데이트
      function updateGroupedTable() {
        const tableHeaders = document.getElementById("tableHeaders");
        const tableBody = document.getElementById("tableBody");

        // 헤더 업데이트 (주요 헤더들만 표시)
        const mainHeaders = [
          "GlobalId",
          "Name",
          "IfcClass",
          "SpatialContainer",
        ];
        const visibleHeaders = headers
          .filter(
            (h) =>
              mainHeaders.includes(h) ||
              ["Area", "Volume", "Length", "Height", "Width"].some((qty) =>
                h.includes(qty)
              )
          )
          .slice(0, 8); // 최대 8개 컬럼만 표시

        tableHeaders.innerHTML = visibleHeaders
          .map((h) => `<th>${h}</th>`)
          .join("");

        // 그룹 기준 수집
        const groupKeys = [];
        for (let i = 1; i <= 3; i++) {
          const value = document.getElementById("groupBy" + i).value;
          if (value) groupKeys.push(value);
        }

        // 테이블 바디 업데이트
        tableBody.innerHTML = "";

        if (groupKeys.length === 0) {
          // 그룹화 없음
          objectData.forEach((obj) => {
            const row = createObjectRow(obj, visibleHeaders);
            tableBody.appendChild(row);
          });
        } else {
          // 그룹화 적용
          const groupedData = groupObjectsByKeys(objectData, groupKeys);
          renderGroupedData(
            tableBody,
            groupedData,
            0,
            groupKeys,
            visibleHeaders
          );
        }
      }

      // 객체 행 생성
      function createObjectRow(obj, visibleHeaders) {
        const row = document.createElement("tr");
        row.className = "object-row";

        visibleHeaders.forEach((header) => {
          const cell = document.createElement("td");
          let value = obj[header];

          if (typeof value === "number") {
            value = value.toLocaleString("ko-KR", { maximumFractionDigits: 2 });
          }

          cell.textContent = value || "";
          cell.title = value || "";
          row.appendChild(cell);
        });

        return row;
      }

      // 객체들을 키로 그룹화
      function groupObjectsByKeys(objects, keys, depth = 0) {
        if (depth >= keys.length) return objects;

        const grouped = {};
        const key = keys[depth];

        objects.forEach((obj) => {
          let value = obj[key] || "N/A";
          if (!grouped[value]) grouped[value] = [];
          grouped[value].push(obj);
        });

        Object.keys(grouped).forEach((key) => {
          grouped[key] = groupObjectsByKeys(grouped[key], keys, depth + 1);
        });

        return grouped;
      }

      // 그룹화된 데이터 렌더링
      function renderGroupedData(
        tbody,
        groupedData,
        depth,
        groupKeys,
        visibleHeaders
      ) {
        Object.entries(groupedData).forEach(([groupValue, content]) => {
          // 그룹 헤더 행
          const groupRow = document.createElement("tr");
          groupRow.className = "group-header";

          const groupCell = document.createElement("td");
          groupCell.colSpan = visibleHeaders.length;
          groupCell.textContent = `${"  ".repeat(depth)}▼ ${
            groupKeys[depth]
          }: ${groupValue}`;
          groupRow.appendChild(groupCell);

          tbody.appendChild(groupRow);

          if (Array.isArray(content)) {
            content.forEach((obj) => {
              const row = createObjectRow(obj, visibleHeaders);
              tbody.appendChild(row);
            });
          } else {
            renderGroupedData(
              tbody,
              content,
              depth + 1,
              groupKeys,
              visibleHeaders
            );
          }
        });
      }

      // AI 모델 정보 로드
      function loadModelInfo() {
        const modelId = document.getElementById("aiModelSelect").value;

        if (!modelId) {
          document.getElementById("modelInfo").classList.add("hidden");
          document
            .getElementById("inputMappingSection")
            .classList.add("hidden");
          return;
        }

        fetch(`/ifc_ai_prediction/api/model/${modelId}/metadata/`)
          .then((response) => response.json())
          .then((data) => {
            selectedModel = data;
            displayModelInfo(data);
            loadAIModel(data);
            createInputMappingUI(data);
          })
          .catch((error) => {
            console.error("모델 정보 로드 실패:", error);
            alert("모델 정보를 로드할 수 없습니다.");
          });
      }

      // AI 모델 로드 (TensorFlow.js)
      async function loadAIModel(modelMetadata) {
        try {
          // ZIP 파일에서 모델 로드
          const modelResponse = await fetch(modelMetadata.model_file_url);
          const zipBlob = await modelResponse.blob();

          const zip = new JSZip();
          const zipContent = await zip.loadAsync(zipBlob);

          // model.json 읽기
          const modelJson = await zipContent.file("model.json").async("string");
          const modelTopology = JSON.parse(modelJson);

          // weights.bin 읽기
          const weightsData = await zipContent
            .file("weights.bin")
            .async("uint8array");

          // TensorFlow.js 모델 로드
          loadedAIModel = await tf.loadLayersModel(
            tf.io.fromMemory(modelTopology, weightsData)
          );

          console.log("✅ AI 모델 로드 완료");
        } catch (error) {
          console.error("❌ AI 모델 로드 실패:", error);
          alert("AI 모델을 로드할 수 없습니다: " + error.message);
        }
      }

      // 모델 정보 표시
      function displayModelInfo(model) {
        const details = `
                <div style="background: #f8f9fa; padding: 12px; border-radius: 4px; font-size: 13px;">
                    <strong>설명:</strong> ${model.description || "없음"}<br>
                    <strong>입력 변수:</strong> ${model.input_columns.join(
                      ", "
                    )}<br>
                    <strong>출력 변수:</strong> ${model.output_columns.join(
                      ", "
                    )}<br>
                    ${
                      model.rmse
                        ? `<strong>RMSE:</strong> ${model.rmse.toFixed(4)}<br>`
                        : ""
                    }
                    ${
                      model.mae
                        ? `<strong>MAE:</strong> ${model.mae.toFixed(4)}<br>`
                        : ""
                    }
                    ${
                      model.r2_score
                        ? `<strong>R² 점수:</strong> ${model.r2_score.toFixed(
                            4
                          )}`
                        : ""
                    }
                </div>
            `;

        document.getElementById("modelDetails").innerHTML = details;
        document.getElementById("modelInfo").classList.remove("hidden");
      }

      // 입력 매핑 UI 생성 (핵심 기능!)
      function createInputMappingUI(model) {
        const container = document.getElementById("inputMappingContainer");
        container.innerHTML = "";

        inputMappings = {};

        model.input_columns.forEach((column, index) => {
          const inputDiv = document.createElement("div");
          inputDiv.className = "input-item";
          inputDiv.innerHTML = `
                    <div class="input-header">${column}</div>
                    
                    <div class="mapping-type-selector">
                        <label>
                            <input type="radio" name="type_${index}" value="manual" checked>
                            직접 입력
                        </label>
                        <label>
                            <input type="radio" name="type_${index}" value="ifc_aggregation">
                            IFC 객체 집계
                        </label>
                    </div>
                    
                    <div class="manual-input-container">
                        <input type="number" class="manual-input" data-column="${column}" 
                               placeholder="값을 입력하세요" step="any">
                    </div>
                    
                    <div class="ifc-aggregation-container hidden">
                        <div class="filter-conditions" data-column="${column}">
                            <!-- 필터 조건들이 여기에 추가됨 -->
                        </div>
                        <button type="button" class="btn-small btn-add" onclick="addFilterCondition('${column}')">
                            + 조건 추가
                        </button>
                        
                        <div class="aggregation-controls">
                            <div class="aggregation-row">
                                <select class="aggregation-attribute" data-column="${column}">
                                    <option value="">집계할 속성 선택</option>
                                    ${headers
                                      .map(
                                        (h) =>
                                          `<option value="${h}">${h}</option>`
                                      )
                                      .join("")}
                                </select>
                                <select class="aggregation-function" data-column="${column}">
                                    <option value="sum">합계</option>
                                    <option value="count">개수</option>
                                    <option value="avg">평균</option>
                                    <option value="min">최솟값</option>
                                    <option value="max">최댓값</option>
                                </select>
                                <button type="button" class="btn-small btn-test" onclick="testAggregation('${column}')">
                                    테스트
                                </button>
                            </div>
                            <div class="aggregation-result hidden" data-column="${column}"></div>
                        </div>
                    </div>
                `;

          container.appendChild(inputDiv);

          // 라디오 버튼 이벤트
          inputDiv
            .querySelectorAll(`input[name="type_${index}"]`)
            .forEach((radio) => {
              radio.addEventListener("change", function () {
                const manualContainer = inputDiv.querySelector(
                  ".manual-input-container"
                );
                const ifcContainer = inputDiv.querySelector(
                  ".ifc-aggregation-container"
                );

                if (this.value === "manual") {
                  manualContainer.classList.remove("hidden");
                  ifcContainer.classList.add("hidden");
                } else {
                  manualContainer.classList.add("hidden");
                  ifcContainer.classList.remove("hidden");
                }

                updateInputMapping(column);
              });
            });

          // 직접 입력 이벤트
          inputDiv
            .querySelector(".manual-input")
            .addEventListener("input", function () {
              updateInputMapping(column);
            });

          // 집계 설정 이벤트
          inputDiv
            .querySelector(".aggregation-attribute")
            .addEventListener("change", function () {
              updateInputMapping(column);
            });
          inputDiv
            .querySelector(".aggregation-function")
            .addEventListener("change", function () {
              updateInputMapping(column);
            });

          // 초기 매핑 설정
          updateInputMapping(column);
        });

        document
          .getElementById("inputMappingSection")
          .classList.remove("hidden");
        updatePredictButton();
      }

      // 입력 매핑 업데이트
      function updateInputMapping(column) {
        const inputDiv = document
          .querySelector(`[data-column="${column}"]`)
          .closest(".input-item");
        const type = inputDiv.querySelector(
          'input[name^="type_"]:checked'
        ).value;

        if (type === "manual") {
          const value = inputDiv.querySelector(".manual-input").value;
          inputMappings[column] = {
            type: "manual",
            value: value || 0,
          };
        } else {
          const attribute = inputDiv.querySelector(
            ".aggregation-attribute"
          ).value;
          const func = inputDiv.querySelector(".aggregation-function").value;

          inputMappings[column] = {
            type: "ifc_aggregation",
            aggregation_attribute: attribute,
            aggregation_function: func,
            filters: [], // 필터 조건들은 별도로 관리
          };
        }

        updatePredictButton();
      }

      // 필터 조건 추가 (사용자가 설명한 복잡한 UI)
      function addFilterCondition(column) {
        const container = document.querySelector(
          `.filter-conditions[data-column="${column}"]`
        );
        const conditionDiv = document.createElement("div");
        conditionDiv.className = "filter-condition";

        const conditionCount = container.children.length;
        const relationHtml =
          conditionCount > 0
            ? `
                <select class="relation-select">
                    <option value="and">그리고</option>
                    <option value="or">또는</option>
                </select>
            `
            : "";

        conditionDiv.innerHTML = `
                ${relationHtml}
                <div class="filter-row">
                    <select class="attribute-select">
                        <option value="">속성 선택</option>
                        ${headers
                          .map((h) => `<option value="${h}">${h}</option>`)
                          .join("")}
                    </select>
                    <input type="text" class="value-input" placeholder="속성값">
                    <select class="condition-select">
                        <option value="equals">같음</option>
                        <option value="contains">포함</option>
                        <option value="starts_with">시작함</option>
                        <option value="ends_with">끝남</option>
                        <option value="greater_than">보다 큼</option>
                        <option value="less_than">보다 작음</option>
                        <option value="greater_equal">크거나 같음</option>
                        <option value="less_equal">작거나 같음</option>
                    </select>
                    <button type="button" class="btn-small btn-remove" onclick="removeFilterCondition(this)">
                        -
                    </button>
                </div>
            `;

        container.appendChild(conditionDiv);
      }

      // 필터 조건 제거
      function removeFilterCondition(button) {
        button.closest(".filter-condition").remove();
      }

      // 집계 테스트
      function testAggregation(column) {
        const inputDiv = document
          .querySelector(`[data-column="${column}"]`)
          .closest(".input-item");
        const attribute = inputDiv.querySelector(
          ".aggregation-attribute"
        ).value;
        const func = inputDiv.querySelector(".aggregation-function").value;

        if (!attribute) {
          alert("집계할 속성을 선택하세요.");
          return;
        }

        // 필터 조건들 수집
        const conditions = [];
        const filterContainer = inputDiv.querySelector(".filter-conditions");

        filterContainer
          .querySelectorAll(".filter-condition")
          .forEach((condition, index) => {
            const attrSelect = condition.querySelector(".attribute-select");
            const condSelect = condition.querySelector(".condition-select");
            const valueInput = condition.querySelector(".value-input");
            const relationSelect = condition.querySelector(".relation-select");

            if (attrSelect.value && condSelect.value && valueInput.value) {
              conditions.push({
                attribute_name: attrSelect.value,
                condition: condSelect.value,
                value: valueInput.value,
                relation: index > 0 ? relationSelect.value : "and",
              });
            }
          });

        // 서버에 필터 조건 저장
        fetch("/ifc_ai_prediction/api/filters/save/", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            session_key: sessionKey,
            conditions: conditions,
          }),
        })
          .then((response) => response.json())
          .then((data) => {
            sessionKey = data.session_key;

            // 집계 테스트
            return fetch(
              `/ifc_ai_prediction/api/project/${PROJECT_ID}/test-aggregation/`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  filter_session_key: sessionKey,
                  aggregation_attribute: attribute,
                  aggregation_function: func,
                }),
              }
            );
          })
          .then((response) => response.json())
          .then((data) => {
            if (data.success) {
              const resultDiv = inputDiv.querySelector(
                `.aggregation-result[data-column="${column}"]`
              );
              resultDiv.innerHTML = `
                        <strong>결과:</strong> ${data.result.toLocaleString(
                          "ko-KR",
                          { maximumFractionDigits: 2 }
                        )}<br>
                        <small>필터링된 객체: ${
                          data.filtered_count
                        }개, 집계된 값: ${data.values_count}개</small>
                    `;
              resultDiv.classList.remove("hidden");
            } else {
              alert("집계 테스트 실패: " + data.error);
            }
          })
          .catch((error) => {
            console.error("집계 테스트 실패:", error);
            alert("집계 테스트 중 오류가 발생했습니다.");
          });
      }

      // 예측 버튼 상태 업데이트
      function updatePredictButton() {
        const btn = document.getElementById("predictBtn");
        const allInputsValid =
          Object.keys(inputMappings).length ===
          selectedModel?.input_columns.length;

        btn.disabled = !allInputsValid || !loadedAIModel;
      }

      // 예측 실행 (핵심!)
      function executePrediction() {
        if (!selectedModel || !loadedAIModel) {
          alert("AI 모델을 선택하고 로드를 완료하세요.");
          return;
        }

        const btn = document.getElementById("predictBtn");
        btn.disabled = true;
        btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 예측 중...';

        // 예측 실행 요청 (입력 데이터 계산)
        fetch(
          `/ifc_ai_prediction/api/project/${PROJECT_ID}/execute-prediction/`,
          {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              ai_model_id: selectedModel.id,
              input_mappings: inputMappings,
            }),
          }
        )
          .then((response) => response.json())
          .then((data) => {
            if (data.success) {
              currentMappingId = data.mapping_id;
              // TensorFlow.js로 실제 예측 실행
              performPrediction(data.input_values, data.execution_time);
            } else {
              throw new Error(data.error);
            }
          })
          .catch((error) => {
            console.error("예측 실행 실패:", error);
            alert("예측 실행 중 오류가 발생했습니다: " + error.message);

            btn.disabled = false;
            btn.innerHTML = '<i class="fas fa-brain"></i> 예측 실행';
          });
      }

      // TensorFlow.js 예측 수행
      async function performPrediction(inputValues, executionTime) {
        try {
          // 입력 데이터를 텐서로 변환
          const inputArray = selectedModel.input_columns.map(
            (col) => inputValues[col] || 0
          );
          const inputTensor = tf.tensor2d([inputArray]);

          // 예측 실행
          const prediction = await loadedAIModel.predict(inputTensor);
          const predictionArray = await prediction.data();
          const predictionValue = predictionArray[0];

          // 오차 범위 계산
          const errorRange = calculateErrorRange(predictionValue);

          // 결과 표시
          displayPredictionResult(
            predictionValue,
            errorRange,
            inputValues,
            executionTime
          );

          // 예측 결과 저장
          await savePrediction(inputValues, predictionValue, errorRange);

          // 메모리 정리
          inputTensor.dispose();
          prediction.dispose();
        } catch (error) {
          console.error("예측 수행 실패:", error);
          alert("예측 수행 중 오류가 발생했습니다: " + error.message);
        } finally {
          // 버튼 복원
          const btn = document.getElementById("predictBtn");
          btn.disabled = false;
          btn.innerHTML = '<i class="fas fa-brain"></i> 예측 실행';
        }
      }

      // 오차 범위 계산
      function calculateErrorRange(prediction) {
        const rmse = selectedModel.rmse || 0;
        const mae = selectedModel.mae || 0;

        const errorMargin = rmse * 1.5;

        return {
          min: Math.max(0, prediction - errorMargin),
          max: prediction + errorMargin,
          confidence: Math.max(0, Math.min(1, 1 - rmse / prediction)),
        };
      }

      // 예측 결과 표시
      function displayPredictionResult(
        prediction,
        errorRange,
        inputValues,
        executionTime
      ) {
        const resultContent = document.getElementById("resultContent");

        // PDF 생성용 데이터 저장
        lastPredictionData = {
          input_values: inputValues,
          prediction_result: { value: prediction },
          prediction_range: errorRange,
        };

        resultContent.innerHTML = `
                <div class="prediction-result">
                    <h5 style="margin-bottom: 15px; color: #0c5460;">
                        <i class="fas fa-chart-line"></i> 예측 결과
                    </h5>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                        <div>
                            <strong>예측값:</strong><br>
                            <span style="font-size: 1.4em; color: #28a745;">${prediction.toLocaleString(
                              "ko-KR",
                              { maximumFractionDigits: 2 }
                            )}</span>
                        </div>
                        <div>
                            <strong>신뢰도:</strong><br>
                            <span style="font-size: 1.4em; color: #17a2b8;">${(
                              errorRange.confidence * 100
                            ).toFixed(1)}%</span>
                        </div>
                    </div>
                    
                    <div style="background: rgba(255,255,255,0.7); padding: 10px; border-radius: 4px;">
                        <strong>예측 범위:</strong><br>
                        최솟값: ${errorRange.min.toLocaleString("ko-KR", {
                          maximumFractionDigits: 2,
                        })}<br>
                        최댓값: ${errorRange.max.toLocaleString("ko-KR", {
                          maximumFractionDigits: 2,
                        })}<br>
                        오차 범위: ±${(
                          (errorRange.max - errorRange.min) /
                          2
                        ).toLocaleString("ko-KR", { maximumFractionDigits: 2 })}
                    </div>
                </div>
                
                <div style="margin-top: 15px;">
                    <h6>입력값 요약</h6>
                    <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; font-size: 13px;">
                        ${Object.entries(inputValues)
                          .map(
                            ([key, value]) =>
                              `<div>${key}: ${value.toLocaleString("ko-KR", {
                                maximumFractionDigits: 2,
                              })}</div>`
                          )
                          .join("")}
                    </div>
                </div>
            `;

        document.getElementById("predictionResult").classList.remove("hidden");

        // 차트 생성
        createResultChart(prediction, errorRange);
      }

      // 결과 차트 생성
      function createResultChart(result, range) {
        const chartContainer = document.getElementById("resultChart");
        chartContainer.innerHTML =
          '<canvas id="resultCanvas" width="300" height="200"></canvas>';

        const ctx = document.getElementById("resultCanvas").getContext("2d");

        new Chart(ctx, {
          type: "bar",
          data: {
            labels: ["최솟값", "예측값", "최댓값"],
            datasets: [
              {
                label: "예측 결과",
                data: [range.min, result, range.max],
                backgroundColor: [
                  "rgba(255, 193, 7, 0.8)",
                  "rgba(40, 167, 69, 0.8)",
                  "rgba(220, 53, 69, 0.8)",
                ],
                borderColor: [
                  "rgba(255, 193, 7, 1)",
                  "rgba(40, 167, 69, 1)",
                  "rgba(220, 53, 69, 1)",
                ],
                borderWidth: 2,
              },
            ],
          },
          options: {
            responsive: true,
            scales: {
              y: {
                beginAtZero: false,
              },
            },
            plugins: {
              legend: {
                display: false,
              },
            },
          },
        });
      }

      // 예측 결과 저장
      async function savePrediction(inputValues, prediction, errorRange) {
        if (!currentMappingId) return;

        try {
          await fetch(
            `/ifc_ai_prediction/api/mapping/${currentMappingId}/save-result/`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                input_values: inputValues,
                prediction_result: { value: prediction },
                prediction_range: errorRange,
                execution_time: 0,
              }),
            }
          );
        } catch (error) {
          console.error("예측 결과 저장 실패:", error);
        }
      }

      // PDF 다운로드 함수
      function downloadPredictionPDF() {
        if (!lastPredictionData || !currentMappingId) {
          alert("예측을 먼저 실행해주세요.");
          return;
        }

        const btn = document.getElementById("downloadPdfBtn");
        const originalHtml = btn.innerHTML;
        btn.innerHTML =
          '<span class="spinner-border spinner-border-sm" role="status"></span> PDF 생성 중...';
        btn.disabled = true;

        try {
          // 차트 이미지를 base64로 추출
          const chartImage = getChartAsImage();

          // 서버에 PDF 생성 요청
          fetch(
            `/ifc_ai_prediction/api/mapping/${currentMappingId}/generate-pdf/1/`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                input_data: lastPredictionData.input_values,
                prediction_result: lastPredictionData.prediction_result,
                prediction_range: lastPredictionData.prediction_range,
                chart_image: chartImage,
              }),
            }
          )
            .then((response) => {
              if (!response.ok) {
                throw new Error("PDF 생성 실패");
              }
              return response.blob();
            })
            .then((blob) => {
              // 파일 다운로드
              const url = URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = url;
              a.download = `ifc_ai_prediction_${new Date()
                .toISOString()
                .slice(0, 10)}.pdf`;
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
            })
            .catch((error) => {
              console.error("PDF 다운로드 오류:", error);
              alert("PDF 다운로드 중 오류가 발생했습니다.");
            })
            .finally(() => {
              btn.innerHTML = originalHtml;
              btn.disabled = false;
            });
        } catch (error) {
          console.error("PDF 처리 오류:", error);
          alert("PDF 처리 중 오류가 발생했습니다.");
          btn.innerHTML = originalHtml;
          btn.disabled = false;
        }
      }

      // 차트를 base64 이미지로 변환
      function getChartAsImage() {
        try {
          const canvas = document.getElementById("resultCanvas");
          if (!canvas) return "";
          return canvas.toDataURL("image/png");
        } catch (error) {
          console.error("차트 이미지 변환 오류:", error);
          return "";
        }
      }
    </script>

    <!-- 3D 뷰어 스크립트 (dd_by_ifc에서 가져옴) -->
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

      const viewDiv = document.getElementById("viewer");
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        60,
        viewDiv.clientWidth / viewDiv.clientHeight,
        0.1,
        10000
      );
      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(viewDiv.clientWidth, viewDiv.clientHeight);
      viewDiv.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      scene.add(new THREE.AmbientLight(0xffffff, 0.8));
      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(10, 10, 10);
      scene.add(dir);

      camera.position.set(10, 10, 10);
      THREE.Object3D.DefaultUp = new THREE.Vector3(0, 0, 1);

      // IFC 로드 및 표시
      const IFC_URL = "{{ ifc_abs_url }}";
      const WHEEL_URL =
        "{% static 'wasm/IfcOpenShell-0.7.0-py3-none-any.whl' %}";

      (async () => {
        try {
          const pyodide = await loadPyodide();
          await pyodide.loadPackage("micropip");
          const micropip = pyodide.pyimport("micropip");
          await micropip.install(WHEEL_URL);

          const ifcText = await (await fetch(IFC_URL)).text();

          const ifcopenshell = pyodide.pyimport("ifcopenshell");
          const ifc = ifcopenshell.file.from_string(ifcText);
          const ifcopenshell_geom = pyodide.pyimport("ifcopenshell.geom");
          const s = ifcopenshell_geom.settings();
          s.set(s.WELD_VERTICES, false);

          const it = ifcopenshell_geom.iterator(s, ifc);

          if (it.initialize()) {
            let geometries = [];
            let lastMeshId = null;

            while (true) {
              const obj = it.get();
              const ty = ifc.by_id(obj.id).is_a();

              if (ty !== "IfcOpeningElement" && ty !== "IfcSpace") {
                if (lastMeshId !== obj.geometry.id) {
                  geometries = [];

                  const materials = obj.geometry.materials.toJs().map(
                    (e) =>
                      new THREE.MeshLambertMaterial({
                        color: new THREE.Color(...e.diffuse.toJs()),
                        opacity: 1.0 - e.transparency,
                        transparent: e.transparency > 1e-5,
                        side: THREE.DoubleSide,
                      })
                  );

                  const mapping = {};
                  obj.geometry.material_ids.toJs().forEach((mid, idx) => {
                    mapping[mid] = mapping[mid] || [];
                    mapping[mid].push(idx);
                  });

                  const vs = new Float32Array(obj.geometry.verts.toJs());
                  const ns = new Float32Array(obj.geometry.normals.toJs());
                  const fs = obj.geometry.faces.toJs();

                  let offset = 0;
                  if (mapping[-1]) {
                    materials.unshift(
                      new THREE.MeshLambertMaterial({
                        color: new THREE.Color(0.6, 0.6, 0.6),
                        side: THREE.DoubleSide,
                      })
                    );
                    offset = 1;
                  }

                  materials.forEach((mat, mi) => {
                    const idxList = mapping[mi - offset];
                    if (!idxList) return;

                    const g = new THREE.BufferGeometry();
                    const flatIdx = [];
                    idxList.forEach((i) => {
                      flatIdx.push(fs[3 * i], fs[3 * i + 1], fs[3 * i + 2]);
                    });
                    g.setIndex(flatIdx);
                    g.setAttribute(
                      "position",
                      new THREE.BufferAttribute(vs, 3)
                    );
                    g.setAttribute("normal", new THREE.BufferAttribute(ns, 3));
                    geometries.push([g, mat]);
                  });

                  lastMeshId = obj.geometry.id;
                }

                geometries.forEach(([g, mat]) => {
                  const mesh = new THREE.Mesh(g, mat);
                  const m = obj.transformation.matrix.data.toJs();
                  const mat4 = new THREE.Matrix4()
                    .set(
                      m[0],
                      m[1],
                      m[2],
                      0,
                      m[3],
                      m[4],
                      m[5],
                      0,
                      m[6],
                      m[7],
                      m[8],
                      0,
                      m[9],
                      m[10],
                      m[11],
                      1
                    )
                    .transpose();
                  mesh.matrixAutoUpdate = false;
                  mesh.matrix = mat4;
                  scene.add(mesh);
                });
              }

              if (!it.next()) break;
            }
          }

          zoomToFit();
          animate();
        } catch (error) {
          console.error("3D 뷰어 로드 실패:", error);
          // 기본 박스 표시
          const geometry = new THREE.BoxGeometry(2, 2, 2);
          const material = new THREE.MeshLambertMaterial({ color: 0x888888 });
          const cube = new THREE.Mesh(geometry, material);
          scene.add(cube);

          camera.position.set(5, 5, 5);
          camera.lookAt(0, 0, 0);
          animate();
        }
      })();

      function zoomToFit() {
        const box = new THREE.Box3().setFromObject(scene);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3()).length();
        const dist = size * 1.5;
        camera.position.copy(
          center.clone().add(new THREE.Vector3(dist, dist, dist))
        );
        camera.lookAt(center);
        controls.target.copy(center);
        controls.update();
      }

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }

      window.addEventListener("resize", () => {
        const w = viewDiv.clientWidth;
        const h = viewDiv.clientHeight;
        renderer.setSize(w, h);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
      });
    </script>
  </body>
</html>
