<!--templates/dd_by_ifc/project_detail.html-->

{% load static %}
<!DOCTYPE html>
<!--  AIBIM Cost‑Estimator – 상세견적(DD) 작업 페이지  -->
<html>
  <head>
    <title>{{ project.name }} - 상세견적 작업</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, user-scalable=no"
    />

    <!-- three.js / OrbitControls ES module importmap -->
    <script type="importmap">
      {
        "imports": {
          "three": "{% static 'js/three.module.js' %}",
          "three/examples/jsm/controls/OrbitControls.js": "{% static 'js/OrbitControls.js' %}"
        }
      }
    </script>
    <script
      async
      src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
    ></script>

    <!-- Pyodide + IfcOpenShell WASM -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.22.0a1/full/pyodide.js"></script>

    <!-- CSS -->
    <link rel="stylesheet" href="{% static 'css/style_dd_by_ifc.css' %}" />
    <link
      rel="stylesheet"
      href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
      integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T"
      crossorigin="anonymous"
    />
    <link rel="stylesheet" href="{% static 'css/main.css' %}" />
  </head>

  <body class="is-preload" data-project-id="{{ project.id }}">
    <!-- ─────────────────────────────  상단 네비게이션 & 메뉴  ───────────────────────────── -->
    <div id="page-wrapper">
      <!-- Header -->
      <div id="header">
        <!-- Logo -->
        <h1>
          <a href="/" id="logo">AIBIM <em>Cost Estimator</em></a>
        </h1>

        <!-- Nav -->
        <nav id="nav">
          <ul>
            <li><a href="/">홈</a></li>
            <li>
              <a href="#">계획설계단계 견적</a>
              <ul>
                <li>
                  <a href="/ai_prediction/">AI 개산견적</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="#">중간설계단계 견적</a>
              <ul>
                <li>
                  <a href="/ifc_ai_prediction/">AI+BIM 개산견적(IFC기반)</a>
                </li>
              </ul>
            </li>
            <li class="current">
              <a href="#">실시설계단계 견적</a>
              <ul>
                <li>
                  <a href="/dd_by_ifc/">AI+BIM 상세견적(IFC기반)</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="/ai_learning">AI모델 학습</a>
            </li>
          </ul>
        </nav>
      </div>

      <div id="nav_sub">
        <h6 class="text-center">
          <b>AI+BIM 상세견적</b> <span>(IFC기반)</span>
        </h6>
      </div>
    </div>

    <!-- ─────────────────────────────  3D Viewer  ───────────────────────────── -->
    <div class="view-container"><div id="viewer"></div></div>

    <!-- ─────────────────────────────  전체 코드 요약 테이블  ───────────────────────────── -->
    <div class="container_detail_first" id="first_container">
      <div class="container_detail">
        <div style="font-weight: bold">공종별 내역서</div>
      </div>
      <div
        class="summary-group-bar"
        id="summaryGroupBar"
        style="margin: 6px 0 10px 0; font-size: 11px"
      >
        <label
          >하위 그룹 기준:
          <select
            id="summaryGroupSelect"
            style="font-size: 11px; padding: 2px 4px"
          >
            <option value="">없음</option>
          </select>
        </label>
      </div>

      <div class="container_detail">
        <div class="table-wrapper" style="overflow-x: auto">
          <table id="summaryTable" class="table table-bordered aibim-table">
            <thead>
              <tr>
                <th style="width: 24px"></th>
                <!-- ← 추가: 펼치기 버튼용 -->
                <th>공사코드</th>
                <th>공종</th>
                <th>명칭</th>
                <th>규격</th>
                <th>단위</th>
                <th>수량</th>
                <th>재료비단가</th>
                <th>재료비</th>
                <th>노무비단가</th>
                <th>노무비</th>
                <th>경비단가</th>
                <th>경비</th>
                <th>합계단가</th>
                <th>총금액</th>
              </tr>
            </thead>
            <tbody id="summaryTableBody"></tbody>
          </table>
        </div>
      </div>
      <div class="container_detail">
        <div class="summary-total-label" id="summaryTotalLabel">
          요약 총 금액: 0 원
        </div>
      </div>
    </div>

    <!-- 펼치기/접기 버튼 -->
    <div>
      <button class="cnv_divide" id="folding_line" onclick="foldingAction()">
        펼치기
      </button>
    </div>

    <!-- ─────────────────────────────  상세 패널 (코드 검색, 그룹핑, 상세 테이블)  ───────────────────────────── -->
    <div id="container_detail_first" style="display: none">
      <div class="container_detail_first">
        <div class="container_detail">
          <!-- 좌측 패널 -->
          <div class="left-panel">
            <ul class="search-results" id="searchResults"></ul>
            <input type="text" id="searchBox" placeholder="공사코드 검색" />
            <button class="btn" id="addCodeBtn">공사코드 추가</button>
            <button class="btn" id="removeCodeBtn">공사코드 삭제</button>
            <button class="btn" id="loadCodeBtn">코드리스트 열기</button>
            <!-- 컬럼 선택 영역 -->
            <div class="column-selector">
              <h4>표시할 필드 선택</h4>
              <div class="column-checkboxes" id="columnCheckboxes"></div>
              <div class="column-buttons">
                <button class="btn-small" id="selectAllColumnsBtn">
                  모두 선택
                </button>
                <button class="btn-small" id="deselectAllColumnsBtn">
                  모두 해제
                </button>
              </div>
            </div>
          </div>
          <!-- 우측 패널 -->
          <div class="right-panel">
            <div class="group-bar">
              <label
                >1단계 그룹:
                <select id="groupBy1">
                  <option>없음</option>
                </select>
              </label>
              <label
                >2단계 그룹:
                <select id="groupBy2">
                  <option>없음</option>
                </select>
              </label>
              <label
                >3단계 그룹:
                <select id="groupBy3">
                  <option>없음</option>
                </select>
              </label>
            </div>
            <div
              class="ifc-table"
              id="ifcTablecontainer_"
              style="max-height: 400px; overflow-y: auto"
            ></div>
          </div>
        </div>
      </div>
      <!-- 상세 코드별 수량/금액 -->
      <div class="container_detail">
        <div class="total-label" id="totalLabel">선택객체별 총금액: 0 원</div>
      </div>
      <div class="container_detail">
        <div class="table-wrapper" style="overflow-x: auto">
          <table class="table table-bordered aibim-table" id="codeDetailTable">
            <thead>
              <tr>
                <!-- 필수 6개 -->
                <th>공사코드</th>
                <th>명칭</th>
                <th>규격</th>
                <th>단위</th>
                <th>산식</th>
                <th>수량</th>

                <!-- 선택: 단가·금액 컬럼 (원하면 유지/추가) -->
                <th>재료비단가</th>
                <th>재료비</th>
                <th>노무비단가</th>
                <th>노무비</th>
                <th>경비단가</th>
                <th>경비</th>
                <th>합계단가</th>
                <th>금액</th>
              </tr>
            </thead>

            <tbody></tbody>
          </table>
        </div>
        <div style="height: 12px"></div>
      </div>

      <!-- 수정된 IFC 다운로드 -->
      <div>
        <button class="btn-block" id="saveIFCBtn">
          수정된 IFC 파일 다운로드
        </button>
      </div>
    </div>

    <!-- 숨겨진 파일 입력 -->
    <div>
      <div class="container">
        <div class="top-bar"></div>
        <div class="container_"></div>
        <input type="file" id="codeFileInput" accept=".csv" class="hidden" />
        <input type="file" id="ifcFileInput" accept=".ifc" class="hidden" />
      </div>
    </div>

    <!-- ─────────────────────────────  공통 JS (jQuery 등)  ───────────────────────────── -->
    <script src="{% static 'js/jquery.min.js'%}"></script>
    <script src="{% static 'js/jquery.dropotron.min.js'%}"></script>
    <script src="{% static 'js/browser.min.js'%}"></script>
    <script src="{% static 'js/breakpoints.min.js'%}"></script>
    <script src="{% static 'js/util.js'%}"></script>
    <script src="{% static 'js/main.js'%}"></script>

    <!-- ─────────────────────────────  펼치기/접기 함수  ───────────────────────────── -->
    <script>
      function foldingAction() {
        const el = document.getElementById("container_detail_first");
        if (el.style.display === "block" || el.style.display === "") {
          el.style.display = "none";
          document.getElementById("folding_line").innerText = "펼치기";
        } else {
          el.style.display = "block";
          document.getElementById("folding_line").innerText = "접기";
        }
      }
    </script>

    <!-- ─────────────────────────────  견적/코드 UI 스크립트 (수정된 API 경로)  ───────────────────────────── -->
    <script>
      // 전역 변수
      const PROJECT_ID = parseInt(document.body.dataset.projectId) || 0;
      let codeData = {};
      let objectData = [];
      let groupedObjects = [];
      let collapsedGroups = new Set();
      let selectedCode = null;
      let selectedObjectIds = [];
      let headers = [];
      let visibleHeaders = []; // 표시할 헤더들

      // ==== Viewer <-> Table Sync State ====
      const guidToRow = new Map(); // guid -> <tr>
      let isSyncingFromViewer = false;
      let isSyncingFromTable = false;
      const selectedGuids = new Set(); // 현재 선택된 GUID들
      let lastClickedRowIdx = -1; // shift 범위 선택용

      // ==== Summary expandable globals ====
      let codeToObjects = new Map(); // code -> [objectData...]
      let expandedCodes = new Set(); // 펼쳐진 공사코드들
      let latestSummaryData = []; // 마지막으로 받은 summary_data 원본 저장

      let summaryGroupBy = ""; // 하위 그룹핑 기준 필드명

      // 공통 util (전역 노출)
      function applyTableSelectionStyles() {
        document
          .querySelectorAll("#ifcTablecontainer_ tr.object-row")
          .forEach((tr) => {
            if (selectedGuids.has(tr.dataset.guid))
              tr.classList.add("selected-row");
            else tr.classList.remove("selected-row");
          });
      }
      function selectRowsByGuids(guidsArray) {
        selectedGuids.clear();
        guidsArray.forEach((g) => selectedGuids.add(g));
        applyTableSelectionStyles();

        // 체크박스 상태도 맞춤
        document
          .querySelectorAll("#ifcTablecontainer_ input.object-checkbox")
          .forEach((cb) => {
            cb.checked = selectedGuids.has(cb.value);
          });

        handleObjectSelection(); // 기존 로직(상세테이블 갱신 등) 재활용
      }
      function handleTableRowClick(e, guid, row) {
        const idx = parseInt(row.dataset.idx, 10);
        const additive = e.ctrlKey || e.metaKey; // 개별 토글
        const range = e.shiftKey && lastClickedRowIdx >= 0; // 범위 선택

        if (range) {
          const rows = Array.from(
            document.querySelectorAll("#ifcTablecontainer_ tr.object-row")
          );
          const [start, end] =
            idx > lastClickedRowIdx
              ? [lastClickedRowIdx, idx]
              : [idx, lastClickedRowIdx];
          for (let i = start; i <= end; i++)
            selectedGuids.add(rows[i].dataset.guid);
        } else {
          if (!additive) selectedGuids.clear();
          if (additive && selectedGuids.has(guid)) selectedGuids.delete(guid);
          else selectedGuids.add(guid);
        }
        lastClickedRowIdx = idx;
        applyTableSelectionStyles();

        // 체크박스 싱크
        const cb = row.querySelector("input.object-checkbox");
        if (cb) cb.checked = selectedGuids.has(guid);

        // 뷰어로 반영
        if (window.ifcViewer && !isSyncingFromViewer) {
          isSyncingFromTable = true;
          window.ifcViewer.setSelection(Array.from(selectedGuids));
          isSyncingFromTable = false;
        }

        handleObjectSelection(); // 기존 상세 테이블 로직 호출
      }

      // 전역에 노출 (모듈 스크립트에서 호출)
      window.selectRowsByGuids = selectRowsByGuids;
      window.applyTableSelectionStyles = applyTableSelectionStyles;
      window.isSyncingFromTable = isSyncingFromTable;
      window.isSyncingFromViewer = isSyncingFromViewer;
      window.selectedGuids = selectedGuids;
      window.guidToRow = guidToRow;
      window.handleTableRowClick = handleTableRowClick;

      // 페이지 로딩 시 안내 메시지 추가
      document.addEventListener("DOMContentLoaded", function () {
        // 기존 초기화 함수들
        loadDefaultCostCodes();
        loadIFCObjects();
        loadSummaryTable();
        initSummaryGroupingUI();

        setupEventHandlers();

        // 사용법 안내를 위한 툴팁 추가
        const saveBtn = document.getElementById("saveIFCBtn");
        if (saveBtn) {
          saveBtn.title =
            "공사코드가 반영된 새로운 IFC 파일을 생성하여 다운로드합니다. 시간이 걸릴 수 있습니다.";

          // 버튼 텍스트도 더 명확하게 변경
          saveBtn.textContent = "공사코드 반영 IFC 파일 다운로드";
        }
      });

      // 기본 코드리스트 로드
      function loadDefaultCostCodes() {
        fetch("{% static 'references/CodeList.csv' %}")
          .then((res) => {
            if (!res.ok) {
              console.log("기본 CodeList.csv 파일을 찾을 수 없습니다.");
              return;
            }
            return res.text();
          })
          .then((text) => {
            if (text) {
              parseCostCodesFromCSV(text);
              // 서버에 자동 업로드
              uploadParsedCodesToServer();
              console.log(
                "기본 코드리스트 로드 완료:",
                Object.keys(codeData).length + "건"
              );
            }
          })
          .catch((err) => console.error("기본 코드리스트 로드 실패:", err));
      }
      function initSummaryGroupingUI() {
        const sel = document.getElementById("summaryGroupSelect");
        if (!sel) return;

        // headers 에서 선택지 구성 (Properties/Quantities 포함 가능)
        // 이미 visibleHeaders 만들 때 썼던 headers를 그대로 이용
        const opts = [...headers]; // 필요시 중복 제거/정렬
        opts.sort((a, b) => a.localeCompare(b));

        opts.forEach((h) => {
          const op = document.createElement("option");
          op.value = h;
          op.textContent = h;
          sel.appendChild(op);
        });

        sel.addEventListener("change", (e) => {
          summaryGroupBy = e.target.value || "";
          // 다시 렌더링 (펼친 것들만 영향받음)
          updateSummaryTableDisplay(latestSummaryData);
        });
      }

      // 파싱된 코드를 서버에 업로드 (API 경로 수정)
      function uploadParsedCodesToServer() {
        if (Object.keys(codeData).length === 0) return;

        console.log(
          "📤 서버에 공사코드 업로드 시도 중...",
          Object.keys(codeData).length + "건"
        );

        // CSV 형태로 변환
        const csvLines = [
          "코드,공종,명칭,규격,단위,산식,재료비단가,노무비단가,경비단가,합계단가",
        ];
        Object.entries(codeData).forEach(([code, data]) => {
          const line = [
            code,
            data["공종"] || "",
            data["명칭"] || "",
            data["규격"] || "",
            data["단위"] || "",
            data["산식"] || "",
            data["재료비단가"] || "0",
            data["노무비단가"] || "0",
            data["경비단가"] || "0",
            data["합계단가"] || "0",
          ].join(",");
          csvLines.push(line);
        });

        const csvContent = csvLines.join("\n");
        const blob = new Blob([csvContent], {
          type: "text/csv;charset=utf-8;",
        });

        const formData = new FormData();
        formData.append("csv_file", blob, "CodeList.csv");

        fetch("/dd_by_ifc/api/load_cost_codes/", {
          method: "POST",
          body: formData,
        })
          .then((response) => response.json())
          .then((data) => {
            if (data.success) {
              console.log("✅ 서버에 공사코드 업로드 완료:", data.message);
              console.log("📊 전체 공사코드 수:", data.total_codes + "개");
            } else {
              console.warn("⚠️ 공사코드 업로드 중 문제:", data.error);
            }
          })
          .catch((error) => {
            console.error("❌ 서버 업로드 실패:", error);
          });
      }

      // CSV 텍스트를 파싱하여 codeData 객체 생성
      function parseCostCodesFromCSV(csvText) {
        const lines = csvText.split(/\r?\n/).filter((x) => x.trim());
        if (lines.length < 2) return;

        const cols = lines[0].split(",").map((x) => x.trim());
        codeData = {};

        for (let i = 1; i < lines.length; i++) {
          const row = lines[i].split(",").map((x) => x.trim());
          const code = row[cols.indexOf("코드")];
          if (!code) continue;

          codeData[code] = {};
          cols.forEach((col, j) => {
            codeData[code][col] = row[j] || "";
          });
        }
      }

      // IFC 객체 데이터 로드 (API 경로 수정)
      // 기존 함수를 이걸로 교체
      function loadIFCObjects() {
        const url = `/dd_by_ifc/api/ifc_objects/${PROJECT_ID}/`;

        return fetch(url, {
          method: "GET",
          headers: { Accept: "application/json" },
        })
          .then((response) => {
            if (!response.ok) {
              throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
              );
            }
            return response.json();
          })
          .then((data) => {
            // 기본 응답 검증
            if (!data || !Array.isArray(data.objects)) {
              throw new Error("서버 응답 형식이 올바르지 않습니다.");
            }

            // 이전 선택 상태 보존
            const prevSelected = new Set(window.selectedGuids || []);

            // 전역 데이터 세팅
            objectData = data.objects;
            headers = data.headers || [];

            // 코드 ↔ 객체 매핑 갱신 (요약표 하위 펼치기용)
            if (typeof buildCodeToObjectsMap === "function") {
              buildCodeToObjectsMap();
            }

            // UI 갱신
            updateGroupComboBoxes();
            updateColumnSelector();
            updateGroupedTable();

            // 선택 유지 & 스타일 반영
            if (prevSelected.size) {
              window.selectRowsByGuids
                ? window.selectRowsByGuids(Array.from(prevSelected))
                : (window.selectedGuids = prevSelected);
              if (typeof applyTableSelectionStyles === "function") {
                applyTableSelectionStyles();
              }
            }

            console.log(
              `✅ IFC 객체 로드 완료: ${
                data.total_count ?? objectData.length
              }개`
            );

            // 이미 상세 선택 중이면 다시 로드
            if (
              Array.isArray(selectedObjectIds) &&
              selectedObjectIds.length > 0
            ) {
              setTimeout(() => {
                if (typeof loadObjectDetails === "function")
                  loadObjectDetails();
              }, 0);
            }

            return data; // Promise 체이닝용
          })
          .catch((error) => {
            console.error("❌ IFC 객체 로드 실패:", error);
            // 알림 함수가 있으면 사용
            if (typeof showNotification === "function") {
              showNotification(`IFC 객체 로드 실패: ${error.message}`, "error");
            }
            alert("IFC 객체를 로드하는데 실패했습니다: " + error.message);
            throw error; // 상위로 에러 전달
          });
      }

      // 요약 테이블 로드 (API 경로 수정)
      function loadSummaryTable() {
        fetch(`/dd_by_ifc/api/summary_table/${PROJECT_ID}/`)
          .then((response) => {
            if (!response.ok) {
              throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
              );
            }
            return response.json();
          })
          .then((data) => {
            latestSummaryData = data.summary_data; // ★ 저장

            updateSummaryTableDisplay(data.summary_data);
            document.getElementById("summaryTotalLabel").textContent =
              "요약 총 금액: " + data.total_sum.toLocaleString("ko-KR") + " 원";
            console.log(`✅ 요약 테이블 로드 완료`);
          })
          .catch((error) => {
            console.error("❌ 요약 테이블 로드 실패:", error);
            alert("요약 테이블을 로드하는데 실패했습니다: " + error.message);
          });
      }

      // 이벤트 핸들러 설정
      function setupEventHandlers() {
        // 검색 기능
        document
          .getElementById("searchBox")
          .addEventListener("input", searchCostCodes);

        // 버튼 이벤트
        document
          .getElementById("addCodeBtn")
          .addEventListener("click", addCostCodeToObjects);
        document
          .getElementById("removeCodeBtn")
          .addEventListener("click", removeCostCodeFromObjects);
        document.getElementById("loadCodeBtn").addEventListener("click", () => {
          document.getElementById("codeFileInput").click();
        });

        // 파일 업로드
        document
          .getElementById("codeFileInput")
          .addEventListener("change", handleCostCodeFileUpload);

        // 그룹 콤보박스
        for (let i = 1; i <= 3; i++) {
          document
            .getElementById("groupBy" + i)
            .addEventListener("change", updateGroupedTable);
        }

        // 컬럼 선택 버튼들
        document
          .getElementById("selectAllColumnsBtn")
          .addEventListener("click", () => selectAllColumns(true));
        document
          .getElementById("deselectAllColumnsBtn")
          .addEventListener("click", () => selectAllColumns(false));

        // ★★★ 총금액 재계산 버튼 이벤트 ★★★
        const recalculateBtn = document.getElementById("recalculateAmountsBtn");
        if (recalculateBtn) {
          recalculateBtn.addEventListener("click", recalculateAllAmounts);
        }
      }

      // 총금액 재계산 함수
      async function recalculateAllAmounts() {
        const btn = document.getElementById("recalculateAmountsBtn");
        if (!btn) return;

        if (
          !confirm(
            "모든 객체의 총금액을 다시 계산하시겠습니까?\n(객체 수가 많으면 시간이 걸릴 수 있습니다)"
          )
        ) {
          return;
        }

        const originalText = btn.textContent;
        btn.disabled = true;
        btn.innerHTML = `
    <div class="spinner-border spinner-border-sm" role="status" style="width: 14px; height: 14px;"></div>
    계산 중...
  `;

        try {
          console.log("🔄 총금액 재계산 시작...");

          const response = await fetch(
            `/dd_by_ifc/api/recalculate_amounts/${PROJECT_ID}/`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
            }
          );

          const data = await response.json();

          if (data.success) {
            console.log(`✅ ${data.message}`);
            showNotification(data.message, "success");

            // 테이블들 새로고침
            console.log("📊 테이블 데이터 새로고침 중...");
            await Promise.all([
              loadIFCObjects(),
              loadSummaryTable(),
              selectedObjectIds.length > 0
                ? loadObjectDetails()
                : Promise.resolve(),
            ]);

            console.log("✅ 모든 데이터 새로고침 완료");
          } else {
            throw new Error(data.error || "알 수 없는 오류");
          }
        } catch (error) {
          console.error("❌ 총금액 재계산 실패:", error);
          showNotification(`❌ 총금액 재계산 실패: ${error.message}`, "error");
          alert(`총금액 재계산 중 오류가 발생했습니다:\n${error.message}`);
        } finally {
          btn.disabled = false;
          btn.innerHTML = originalText;
        }
      }
      // 개선된 알림 함수 (에러 타입 추가)
      function showNotification(message, type = "info") {
        // 기존 알림이 있으면 제거
        const existingNotification =
          document.getElementById("notification-toast");
        if (existingNotification) {
          existingNotification.remove();
        }

        // 타입별 색상 설정
        const colors = {
          success: "#28a745",
          warning: "#ffc107",
          error: "#dc3545",
          info: "#17a2b8",
        };

        // 새 알림 생성
        const notification = document.createElement("div");
        notification.id = "notification-toast";
        notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 12px 20px;
    background-color: ${colors[type] || colors.info};
    color: white;
    border-radius: 4px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    z-index: 10000;
    font-size: 14px;
    max-width: 400px;
    animation: slideIn 0.3s ease-out;
    cursor: pointer;
  `;
        notification.textContent = message;

        // CSS 애니메이션 추가 (중복 방지)
        if (!document.getElementById("notification-styles")) {
          const styles = document.createElement("style");
          styles.id = "notification-styles";
          styles.textContent = `
      @keyframes slideIn {
        from { transform: translateX(100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
      }
      @keyframes slideOut {
        from { transform: translateX(0); opacity: 1; }
        to { transform: translateX(100%); opacity: 0; }
      }
      .spinner-border-sm {
        display: inline-block;
        width: 1rem;
        height: 1rem;
        border: 0.125em solid currentColor;
        border-right-color: transparent;
        border-radius: 50%;
        animation: spinner-border 0.75s linear infinite;
      }
      @keyframes spinner-border {
        to { transform: rotate(360deg); }
      }
    `;
          document.head.appendChild(styles);
        }

        document.body.appendChild(notification);

        // 자동 제거 시간 (에러는 더 오래 표시)
        const autoRemoveTime = type === "error" ? 5000 : 3000;

        setTimeout(() => {
          if (notification.parentNode) {
            notification.style.animation = "slideOut 0.3s ease-in";
            setTimeout(() => {
              if (notification.parentNode) {
                notification.remove();
              }
            }, 300);
          }
        }, autoRemoveTime);

        // 클릭시 즉시 제거
        notification.addEventListener("click", () => {
          notification.style.animation = "slideOut 0.3s ease-in";
          setTimeout(() => {
            if (notification.parentNode) {
              notification.remove();
            }
          }, 300);
        });
      }
      // 공사코드 검색
      function searchCostCodes() {
        const query = document
          .getElementById("searchBox")
          .value.trim()
          .toLowerCase();
        const resultsContainer = document.getElementById("searchResults");
        resultsContainer.innerHTML = "";

        if (!query || Object.keys(codeData).length === 0) return;

        Object.entries(codeData).forEach(([code, data]) => {
          if (
            code.toLowerCase().includes(query) ||
            (data["명칭"] || "").toLowerCase().includes(query)
          ) {
            const li = document.createElement("li");
            li.textContent = `${code} - ${data["명칭"]} (${data["규격"]}, ${data["단위"]})`;
            li.onclick = () => selectCostCode(code, li);
            resultsContainer.appendChild(li);
          }
        });
      }

      // 공사코드 선택
      function selectCostCode(code, element) {
        document
          .querySelectorAll("#searchResults li")
          .forEach((li) => li.classList.remove("selected"));
        element.classList.add("selected");
        selectedCode = code;
      }

      // 그룹 콤보박스 업데이트
      function updateGroupComboBoxes() {
        for (let i = 1; i <= 3; i++) {
          const combo = document.getElementById("groupBy" + i);
          const currentValue = combo.value;
          combo.innerHTML = "<option>없음</option>";

          // 헤더들을 오름차순으로 정렬
          const sortedHeaders = [...headers].sort((a, b) => a.localeCompare(b));

          sortedHeaders.forEach((header) => {
            const option = document.createElement("option");
            option.value = header;
            option.textContent = header;
            combo.appendChild(option);
          });

          if (currentValue && headers.includes(currentValue)) {
            combo.value = currentValue;
          }
        }
      }

      // 컬럼 선택 체크박스 업데이트
      function updateColumnSelector() {
        const container = document.getElementById("columnCheckboxes");
        container.innerHTML = "";

        // 기본적으로 처음 6개 컬럼만 선택
        const defaultVisibleColumns = [
          "GlobalId",
          "Name",
          "IfcClass",
          "CostItems",
          "총금액",
          "SpatialContainer",
        ];

        if (visibleHeaders.length === 0) {
          visibleHeaders = headers.filter((h) =>
            defaultVisibleColumns.includes(h)
          );
        }

        headers.forEach((header) => {
          const div = document.createElement("div");
          div.className = "column-checkbox";

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.id = `col_${header}`;
          checkbox.value = header;
          checkbox.checked = visibleHeaders.includes(header);
          checkbox.addEventListener("change", handleColumnToggle);

          const label = document.createElement("label");
          label.htmlFor = `col_${header}`;
          label.textContent = header;

          div.appendChild(checkbox);
          div.appendChild(label);
          container.appendChild(div);
        });
      }

      // 컬럼 토글 처리
      function handleColumnToggle() {
        const checkedBoxes = document.querySelectorAll(
          '#columnCheckboxes input[type="checkbox"]:checked'
        );
        visibleHeaders = Array.from(checkedBoxes).map((cb) => cb.value);
        updateGroupedTable();
      }

      // 모든 컬럼 선택/해제
      function selectAllColumns(select) {
        const checkboxes = document.querySelectorAll(
          '#columnCheckboxes input[type="checkbox"]'
        );
        checkboxes.forEach((cb) => (cb.checked = select));
        handleColumnToggle();
      }

      // 그룹화된 테이블 업데이트
      // ────────────────────────────────────────────────────────────────
      // 완성본: updateGroupedTable()
      //  - 기준코드 스타일의 선택/동기화/그룹핑/헤더생성 모두 포함
      //  - 외부에서 필요한 전역: objectData, headers, visibleHeaders,
      //    collapsedGroups(Set), guidToRow(Map), selectedGuids(Set),
      //    createObjectRow(obj, idx), applyTableSelectionStyles(),
      //    handleObjectSelection(), toggleGroup(key)  (이미 있다면 그대로 사용)
      // ────────────────────────────────────────────────────────────────
      function updateGroupedTable() {
        const container = document.getElementById("ifcTablecontainer_");
        if (!container) return;

        // 초기화
        container.innerHTML = "";
        guidToRow.clear();

        // 그룹 키 수집
        const groupKeys = [];
        for (let i = 1; i <= 3; i++) {
          const v = document.getElementById("groupBy" + i)?.value;
          if (v && v !== "없음") groupKeys.push(v);
        }

        // visibleHeaders 기본값 보정
        if (!Array.isArray(visibleHeaders) || visibleHeaders.length === 0) {
          visibleHeaders = (headers || []).slice(0, 6); // 혹시 비어있으면 앞 6개 임시
        }

        // 테이블 골격
        const table = document.createElement("table");
        table.className = "table table-bordered aibim-table";

        const thead = document.createElement("thead");
        const headerRow = document.createElement("tr");

        // 전체선택 체크박스
        const cbTh = document.createElement("th");
        cbTh.innerHTML = '<input type="checkbox" id="selectAllCheckbox">';
        headerRow.appendChild(cbTh);

        // 데이터 헤더
        visibleHeaders.forEach((h) => {
          const th = document.createElement("th");
          th.textContent = h.split(".").pop();
          headerRow.appendChild(th);
        });

        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement("tbody");
        table.appendChild(tbody);
        container.appendChild(table);

        // row index (shift 선택용)
        let rowCounter = 0;

        // ===== 내부 헬퍼들 =====
        function renderGroup(tbody, groupedData, depth) {
          Object.entries(groupedData).forEach(([groupValue, content]) => {
            const groupKey = `${groupKeys[depth]}:${groupValue}`;
            const isCollapsed = collapsedGroups.has(groupKey);
            const symbol = isCollapsed ? "▶" : "▼";

            // 그룹 헤더 행
            const gRow = document.createElement("tr");
            gRow.className = "group-header";
            gRow.style.backgroundColor = "#f0f0f0";
            gRow.style.fontWeight = "bold";
            gRow.style.cursor = "pointer";

            const gCell = document.createElement("td");
            gCell.colSpan = visibleHeaders.length + 1; // +1 은 체크박스 열
            gCell.textContent = `${" ".repeat(depth * 2)}${symbol} ${
              groupKeys[depth]
            }: ${groupValue}`;
            gRow.appendChild(gCell);

            gRow.addEventListener("click", () => toggleGroup(groupKey));
            tbody.appendChild(gRow);

            if (!isCollapsed) {
              if (Array.isArray(content)) {
                content.forEach((obj) => {
                  const row = createObjectRow(obj, rowCounter++);
                  tbody.appendChild(row);
                });
              } else {
                renderGroup(tbody, content, depth + 1);
              }
            }
          });
        }

        function groupObjectsByKeysLocal(objects, keys, depth = 0) {
          if (depth >= keys.length) return objects;
          const grouped = {};
          const key = keys[depth];

          objects.forEach((obj) => {
            let v = obj[key];
            if (v === undefined && obj.Quantities) v = obj.Quantities[key];
            if (v === undefined && obj.Properties) v = obj.Properties[key];
            if (v === undefined) v = "N/A";
            if (!grouped[v]) grouped[v] = [];
            grouped[v].push(obj);
          });

          Object.keys(grouped).forEach((k) => {
            grouped[k] = groupObjectsByKeysLocal(grouped[k], keys, depth + 1);
          });
          return grouped;
        }

        // ===== 실제 렌더링 =====
        if (groupKeys.length === 0) {
          objectData.forEach((obj) => {
            const row = createObjectRow(obj, rowCounter++);
            tbody.appendChild(row);
          });
        } else {
          const grouped = groupObjectsByKeysLocal(objectData, groupKeys);
          renderGroup(tbody, grouped, 0);
        }

        // 전체선택 체크박스 이벤트
        const selectAllBox = document.getElementById("selectAllCheckbox");
        if (selectAllBox) {
          selectAllBox.addEventListener("change", function () {
            const check = this.checked;
            document
              .querySelectorAll("#ifcTablecontainer_ input.object-checkbox")
              .forEach((cb) => {
                cb.checked = check;
                const guid = cb.value;
                if (check) selectedGuids.add(guid);
                else selectedGuids.delete(guid);
              });

            applyTableSelectionStyles();

            // 뷰어에 반영
            if (window.ifcViewer && !isSyncingFromViewer) {
              isSyncingFromTable = true;
              window.ifcViewer.setSelection(Array.from(selectedGuids));
              isSyncingFromTable = false;
            }

            handleObjectSelection(); // 기존 상세테이블 갱신
          });
        }

        // 기존 선택 상태 반영
        applyTableSelectionStyles();

        // 헤더 체크박스 indeterminate 처리
        const allCbs = document.querySelectorAll(
          "#ifcTablecontainer_ input.object-checkbox"
        );
        const selCbs = document.querySelectorAll(
          "#ifcTablecontainer_ input.object-checkbox:checked"
        );
        if (selectAllBox) {
          selectAllBox.checked =
            allCbs.length > 0 && selCbs.length === allCbs.length;
          selectAllBox.indeterminate =
            selCbs.length > 0 && selCbs.length < allCbs.length;
        }
      }

      // 객체 행 생성
      function createObjectRow(obj, index) {
        const row = document.createElement("tr");
        row.className = "object-row";
        row.dataset.idx = index;

        const guid = obj.GlobalId || obj.globalId || obj.GUID || obj.Guid || "";
        row.dataset.guid = guid;
        if (guid) guidToRow.set(guid, row);

        // 체크박스
        const checkboxCell = document.createElement("td");
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.value = guid;
        checkbox.className = "object-checkbox";
        checkbox.addEventListener("change", () => {
          // 체크박스만 클릭한 경우에도 selection sync
          const additive = true; // 체크는 항상 add/remove
          if (checkbox.checked) selectedGuids.add(guid);
          else selectedGuids.delete(guid);

          applyTableSelectionStyles();

          if (window.ifcViewer && !isSyncingFromViewer) {
            isSyncingFromTable = true;
            window.ifcViewer.setSelection(Array.from(selectedGuids));
            isSyncingFromTable = false;
          }
          handleObjectSelection();
        });
        checkboxCell.appendChild(checkbox);
        row.appendChild(checkboxCell);

        // 행 클릭 시(체크박스 외) 선택 처리
        row.addEventListener("click", (e) => {
          if (e.target === checkbox) return;
          if (!guid) return;
          handleTableRowClick(e, guid, row);
        });

        // 보이는 헤더들만 데이터 셀 생성
        visibleHeaders.forEach((header) => {
          const cell = document.createElement("td");
          let value = obj[header];

          if (value === undefined && obj.Quantities && obj.Quantities[header]) {
            value = obj.Quantities[header];
          }
          if (value === undefined && obj.Properties && obj.Properties[header]) {
            value = obj.Properties[header];
          }

          if (typeof value === "number") {
            value =
              value % 1 === 0
                ? value.toLocaleString("ko-KR")
                : value.toLocaleString("ko-KR", { maximumFractionDigits: 3 });
          }
          cell.textContent = value ?? "";
          cell.title = value ?? "";
          row.appendChild(cell);
        });

        return row;
      }

      // 객체들을 키로 그룹화
      function groupObjectsByKeys(objects, keys, depth = 0) {
        if (depth >= keys.length) return objects;

        const grouped = {};
        const key = keys[depth];

        objects.forEach((obj) => {
          let value = obj[key];
          if (value === undefined && obj.Quantities)
            value = obj.Quantities[key];
          if (value === undefined && obj.Properties)
            value = obj.Properties[key];
          if (value === undefined) value = "N/A";

          if (!grouped[value]) grouped[value] = [];
          grouped[value].push(obj);
        });

        Object.keys(grouped).forEach((key) => {
          grouped[key] = groupObjectsByKeys(grouped[key], keys, depth + 1);
        });

        return grouped;
      }

      // 그룹화된 데이터 렌더링
      function renderGroupedData(
        tbody,
        groupedData,
        depth,
        groupKeys,
        rowCounter
      ) {
        Object.entries(groupedData).forEach(([groupValue, content]) => {
          const groupKey = `${groupKeys[depth]}:${groupValue}`;
          const isCollapsed = collapsedGroups.has(groupKey);
          const symbol = isCollapsed ? "▶" : "▼";

          const groupRow = document.createElement("tr");
          groupRow.className = "group-header";
          groupRow.style.backgroundColor = "#f0f0f0";
          groupRow.style.fontWeight = "bold";
          groupRow.style.cursor = "pointer";

          const groupCell = document.createElement("td");
          groupCell.colSpan = visibleHeaders.length + 1;
          groupCell.textContent = `${" ".repeat(depth * 2)}${symbol} ${
            groupKeys[depth]
          }: ${groupValue}`;
          groupRow.appendChild(groupCell);

          groupRow.addEventListener("click", () => toggleGroup(groupKey));
          tbody.appendChild(groupRow);

          if (!isCollapsed) {
            if (Array.isArray(content)) {
              content.forEach((obj) => {
                const row = createObjectRow(obj, rowCounter++);
                tbody.appendChild(row);
              });
            } else {
              rowCounter = renderGroupedData(
                tbody,
                content,
                depth + 1,
                groupKeys,
                rowCounter
              );
            }
          }
        });
        return rowCounter;
      }
      // 그룹 토글
      function toggleGroup(groupKey) {
        if (collapsedGroups.has(groupKey)) {
          collapsedGroups.delete(groupKey);
        } else {
          collapsedGroups.add(groupKey);
        }
        updateGroupedTable();
      }

      // 객체 선택 처리 개선
      function handleObjectSelection() {
        const selectedCheckboxes = document.querySelectorAll(
          "input.object-checkbox:checked"
        );
        selectedObjectIds = Array.from(selectedCheckboxes).map(
          (cb) => cb.value
        );

        console.log(`🔍 선택된 객체: ${selectedObjectIds.length}개`);

        // 선택된 행 스타일 업데이트
        document.querySelectorAll(".object-row").forEach((row) => {
          const checkbox = row.querySelector("input.object-checkbox");
          if (checkbox && checkbox.checked) {
            row.classList.add("selected");
          } else {
            row.classList.remove("selected");
          }
        });

        // 전체 선택 체크박스 상태 업데이트
        const allCheckboxes = document.querySelectorAll(
          "input.object-checkbox"
        );
        const allSelected =
          allCheckboxes.length > 0 &&
          selectedCheckboxes.length === allCheckboxes.length;
        const someSelected = selectedCheckboxes.length > 0;

        const selectAllCheckbox = document.getElementById("selectAllCheckbox");
        if (selectAllCheckbox) {
          selectAllCheckbox.checked = allSelected;
          selectAllCheckbox.indeterminate = someSelected && !allSelected;
        }

        // 상세 정보 로드 (항상 호출하여 선택 해제도 처리)
        loadObjectDetails();
      }
      // IFC 저장 (다운로드) 개선 - 새 파일 생성 방식
      document
        .getElementById("saveIFCBtn")
        .addEventListener("click", function () {
          if (
            confirm(
              "공사코드가 반영된 새로운 IFC 파일을 생성하여 다운로드하시겠습니까?\n(파일 생성에 시간이 걸릴 수 있습니다)"
            )
          ) {
            const btn = this;
            const originalText = btn.textContent;

            btn.disabled = true;
            btn.innerHTML = `
      <div class="spinner-border spinner-border-sm" role="status"></div>
      새 IFC 파일 생성 중... 잠시만 기다려주세요
    `;

            // 새로운 API 엔드포인트 호출
            const downloadUrl = `/dd_by_ifc/api/download_new_ifc/${PROJECT_ID}/`;

            // fetch로 다운로드 상태 확인
            fetch(downloadUrl)
              .then((response) => {
                if (!response.ok) {
                  return response.json().then((data) => {
                    throw new Error(data.error || "파일 생성 실패");
                  });
                }

                // 성공적으로 받으면 파일 다운로드
                return response.blob();
              })
              .then((blob) => {
                // Blob을 파일로 다운로드
                const url = window.URL.createObjectURL(blob);
                const link = document.createElement("a");
                link.href = url;
                link.download = `${PROJECT_ID}_with_costcodes.ifc`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                window.URL.revokeObjectURL(url);

                // 성공 메시지
                alert(
                  "✅ 공사코드가 반영된 새로운 IFC 파일이 다운로드되었습니다!"
                );
              })
              .catch((error) => {
                console.error("❌ IFC 파일 생성 실패:", error);
                alert(`❌ IFC 파일 생성 실패: ${error.message}`);
              })
              .finally(() => {
                // 버튼 복원
                btn.disabled = false;
                btn.innerHTML = originalText;
              });
          }
        });

      // 전체 선택 토글
      function toggleSelectAll() {
        const selectAll = document.getElementById("selectAllCheckbox").checked;
        const checkboxes = document.querySelectorAll("input.object-checkbox");

        checkboxes.forEach((checkbox) => {
          checkbox.checked = selectAll;
        });

        handleObjectSelection();
        applyTableSelectionStyles();
      }

      // loadObjectDetails 함수만 아래처럼 수정!
      function loadObjectDetails() {
        if (selectedObjectIds.length === 0) {
          clearObjectDetails();
          return;
        }

        const formData = new FormData();
        formData.append("project_id", PROJECT_ID); // <== 반드시 추가!
        selectedObjectIds.forEach((id) => formData.append("object_ids[]", id));

        fetch("/dd_by_ifc/api/object_details/", {
          method: "POST",
          body: formData,
        })
          .then((response) => {
            if (!response.ok) {
              throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
              );
            }
            return response.json();
          })
          .then((data) => {
            updateDetailTable(data.details);
            document.getElementById("totalLabel").textContent =
              "총 금액: " + data.total_amount.toLocaleString("ko-KR") + " 원";
            console.log(
              `✅ 객체 상세 정보 로드 완료: ${data.details.length}개 코드`
            );
          })
          .catch((error) => {
            console.error("❌ 객체 상세 정보 로드 실패:", error);
            alert("객체 상세 정보를 로드하는데 실패했습니다: " + error.message);
            clearObjectDetails();
          });
      }

      // 상세 테이블 업데이트
      function updateDetailTable(details) {
        const tbody = document.querySelector("#codeDetailTable tbody");
        tbody.innerHTML = "";

        details.forEach((d) => {
          const row = document.createElement("tr");
          row.innerHTML = `
      <td>${d.code}</td>
      <td>${d.name}</td>
      <td>${d.specification}</td>
      <td>${d.unit}</td>
      <td>${d.formula}</td>
      <td>${formatNumber(d.quantity)}</td>

      <!-- 단가·금액은 필요 시 포함 -->
      <td>${formatNumber(d.material_unit_price)}</td>
      <td>${formatNumber(d.material_amount)}</td>
      <td>${formatNumber(d.labor_unit_price)}</td>
      <td>${formatNumber(d.labor_amount)}</td>
      <td>${formatNumber(d.expense_unit_price)}</td>
      <td>${formatNumber(d.expense_amount)}</td>
      <td>${formatNumber(d.total_unit_price)}</td>
      <td>${formatNumber(d.total_amount)}</td>
    `;
          tbody.appendChild(row);
        });
      }

      // 상세 정보 클리어
      function clearObjectDetails() {
        document.querySelector("#codeDetailTable tbody").innerHTML = "";
        document.getElementById("totalLabel").textContent = "총 금액: 0 원";
      }

      function addCostCodeToObjects() {
        if (!selectedCode || selectedObjectIds.length === 0) {
          alert("공사코드와 객체를 선택해주세요.");
          return;
        }

        const addBtn = document.getElementById("addCodeBtn");
        const originalText = addBtn.textContent;
        addBtn.disabled = true;
        addBtn.textContent = "추가 중...";

        const formData = new FormData();
        selectedObjectIds.forEach((id) => formData.append("object_ids[]", id));
        formData.append("cost_code", selectedCode);
        formData.append("project_id", PROJECT_ID); // ← ★★★ 반드시 추가!

        fetch("/dd_by_ifc/api/add_cost_code/", {
          method: "POST",
          body: formData,
        })
          .then((response) => {
            if (!response.ok) {
              throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
              );
            }
            return response.json();
          })
          .then((data) => {
            if (data.success) {
              alert(
                `✅ ${data.message}\n\n💡 변경사항이 IFC 파일에 반영되려면 "수정된 IFC 파일 다운로드" 버튼을 클릭하세요.`
              );
              loadIFCObjects();
              loadSummaryTable();
              if (selectedObjectIds.length > 0) {
                setTimeout(() => loadObjectDetails(), 500);
              }
            } else {
              throw new Error(data.error || "알 수 없는 오류");
            }
          })
          .catch((error) => {
            console.error("❌ 공사코드 추가 실패:", error);
            alert("❌ 공사코드 추가 중 오류가 발생했습니다: " + error.message);
          })
          .finally(() => {
            addBtn.disabled = false;
            addBtn.textContent = originalText;
          });
      }

      function removeCostCodeFromObjects() {
        if (selectedObjectIds.length === 0) {
          alert("객체를 선택해주세요.");
          return;
        }

        const selectedDetailRow = document.querySelector(
          "#codeDetailTable tbody tr.selected"
        );
        if (!selectedDetailRow) {
          alert("제거할 공사코드를 상세 테이블에서 선택해주세요.");
          return;
        }

        const codeToRemove = selectedDetailRow.children[0].textContent;

        if (!confirm(`공사코드 "${codeToRemove}"를 제거하시겠습니까?`)) {
          return;
        }

        const removeBtn = document.getElementById("removeCodeBtn");
        const originalText = removeBtn.textContent;
        removeBtn.disabled = true;
        removeBtn.textContent = "제거 중...";

        const formData = new FormData();
        formData.append("project_id", PROJECT_ID); // ← 반드시 추가!
        selectedObjectIds.forEach((id) => formData.append("object_ids[]", id));
        formData.append("cost_code", codeToRemove); // ← selectedCode → codeToRemove로 변경

        // 이 부분이 중요! 'add_cost_code' → 'remove_cost_code'로 변경
        fetch("/dd_by_ifc/api/remove_cost_code/", {
          method: "POST",
          body: formData,
        })
          .then((response) => {
            if (!response.ok) {
              throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
              );
            }
            return response.json();
          })
          .then((data) => {
            if (data.success) {
              alert(
                `✅ ${data.message}\n\n💡 변경사항이 IFC 파일에 반영되려면 "수정된 IFC 파일 다운로드" 버튼을 클릭하세요.`
              );
              console.log(
                `✅ 공사코드 제거 성공: ${data.updated_objects}개 객체`
              );

              // 데이터 새로고침
              loadIFCObjects();
              loadSummaryTable();

              if (selectedObjectIds.length > 0) {
                setTimeout(() => loadObjectDetails(), 500);
              }
            } else {
              throw new Error(data.error || "알 수 없는 오류");
            }
          })
          .catch((error) => {
            console.error("❌ 공사코드 제거 실패:", error);
            alert("❌ 공사코드 제거 중 오류가 발생했습니다: " + error.message);
          })
          .finally(() => {
            removeBtn.disabled = false;
            removeBtn.textContent = originalText;
          });
      }

      // 상세 테이블 행 선택 (delegation)
      document.addEventListener("click", function (e) {
        if (e.target.closest("#codeDetailTable tbody tr")) {
          document
            .querySelectorAll("#codeDetailTable tbody tr")
            .forEach((row) => row.classList.remove("selected"));
          e.target.closest("tr").classList.add("selected");
        }
      });
      // ────────────────────────────────────────────────
      // 요약표 행 클릭 → 해당 코드의 모든 객체 선택 & 동기화
      // ────────────────────────────────────────────────
      document.addEventListener("click", (e) => {
        const expanderClicked = e.target.closest(".summary-expander-btn");
        // expander 버튼 클릭이면 여기서 처리하지 않음 (기존 토글 핸들러에 맡김)
        if (expanderClicked) return;

        const tr = e.target.closest(".summary-code-row");
        if (!tr) return; // 요약표 코드행이 아님
        const code = tr.dataset.code;
        if (!code) return;

        // 객체 GUID 목록 추출
        const objs = codeToObjects.get(code) || [];
        const guids = objs
          .map((o) => o.GlobalId || o.globalId || o.GUID || o.Guid)
          .filter(Boolean);

        // 선택 반영
        selectRowsByGuids(guids);
        if (window.ifcViewer) {
          window.ifcViewer.setSelection(guids);
        }

        // 요약표 행 하이라이트
        document
          .querySelectorAll(".summary-code-row")
          .forEach((r) => r.classList.remove("selected-main"));
        tr.classList.add("selected-main");

        // 하위(펼친) 표가 있다면 그 안의 행들도 하이라이트
        if (expandedCodes.has(code)) {
          const tbody = document.querySelector(
            `.summary-child-row[data-code="${code}"] table.summary-child-table tbody`
          );
          if (tbody) {
            tbody.querySelectorAll("tr").forEach((r) => {
              if (guids.includes(r.dataset.guid))
                r.classList.add("selected-row");
              else r.classList.remove("selected-row");
            });
          }
        }
      });

      // 코드 파일 업로드 처리 (API 경로 수정)
      function handleCostCodeFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        const formData = new FormData();
        formData.append("csv_file", file);

        fetch("/dd_by_ifc/api/load_cost_codes/", {
          method: "POST",
          body: formData,
        })
          .then((response) => {
            if (!response.ok) {
              throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
              );
            }
            return response.json();
          })
          .then((data) => {
            if (data.success) {
              alert(data.message);
              console.log(
                `✅ 코드 파일 업로드 성공: ${data.total_codes}개 코드`
              );
            } else {
              throw new Error(data.error || "알 수 없는 오류");
            }
          })
          .catch((error) => {
            console.error("❌ 코드 파일 업로드 실패:", error);
            alert("파일 업로드 중 오류가 발생했습니다: " + error.message);
          });
      }

      /* ======================================================================
   공사코드별 객체 펼치기 – Summary Table 확장판
   - 기존 updateSummaryTableDisplay() 교체
   - codeToObjects / expandedCodes / latestSummaryData 사용
   - nested table 클릭 시 3D/IFC테이블 동기화
====================================================================== */

      // 코스트코드 ↔ 객체 매핑 생성
      function buildCodeToObjectsMap() {
        codeToObjects.clear();
        if (!Array.isArray(objectData)) return;

        objectData.forEach((obj) => {
          let s =
            obj.CostItems || (obj.Properties && obj.Properties.CostItems) || "";
          if (!s) return;
          const codes = s
            .split("+")
            .map((c) => c.trim())
            .filter(Boolean);
          codes.forEach((code) => {
            if (!codeToObjects.has(code)) codeToObjects.set(code, []);
            codeToObjects.get(code).push(obj);
          });
        });
      }

      // 요약표 UI 갱신
      function updateSummaryTableDisplay(summaryData) {
        const tbody = document.getElementById("summaryTableBody");
        if (!tbody) return;
        tbody.innerHTML = "";

        summaryData.forEach((item) => {
          if (item.type === "group") {
            const tr = document.createElement("tr");
            tr.className = "group-header";

            const td = document.createElement("td");
            td.colSpan = 15; // 14컬럼 + expander col
            td.textContent = `▼ 공종: ${item.group} (총금액: ${formatNumber(
              item.total
            )} 원)`;
            tr.appendChild(td);

            tbody.appendChild(tr);
            return;
          }

          // 일반 코드 행
          const tr = document.createElement("tr");
          tr.dataset.code = item.code || "";
          tr.className = "summary-code-row";

          // 펼치기 버튼 셀
          const tdBtn = document.createElement("td");
          tdBtn.className = "expander-col";
          const btn = document.createElement("button");
          btn.className = "summary-expander-btn";
          btn.dataset.code = item.code || "";
          btn.textContent = expandedCodes.has(item.code) ? "−" : "+";
          tdBtn.appendChild(btn);
          tr.appendChild(tdBtn);

          // 나머지 데이터 셀들
          tr.innerHTML += `
      <td>${item.code || ""}</td>
      <td>${item.category || ""}</td>
      <td>${item.name || ""}</td>
      <td>${item.specification || ""}</td>
      <td>${item.unit || ""}</td>
      <td>${formatNumber(item.quantity)}</td>
      <td>${formatNumber(item.material_unit_price)}</td>
      <td>${formatNumber(item.material_amount)}</td>
      <td>${formatNumber(item.labor_unit_price)}</td>
      <td>${formatNumber(item.labor_amount)}</td>
      <td>${formatNumber(item.expense_unit_price)}</td>
      <td>${formatNumber(item.expense_amount)}</td>
      <td>${formatNumber(item.total_unit_price)}</td>
      <td>${formatNumber(item.total_amount)}</td>
    `;

          tbody.appendChild(tr);

          // 펼쳐진 상태면 하위(객체) 테이블 렌더링
          if (expandedCodes.has(item.code)) {
            const childTr = document.createElement("tr");
            childTr.className = "summary-child-row";
            childTr.dataset.code = item.code;

            const td = document.createElement("td");
            td.colSpan = 15;

            const wrapper = document.createElement("div");
            wrapper.className = "summary-child-wrapper";
            wrapper.appendChild(createNestedObjectTable(item.code));

            td.appendChild(wrapper);
            childTr.appendChild(td);
            tbody.appendChild(childTr);
          }
        });
      }

      // 하위 객체테이블 생성
      function createNestedObjectTable(code) {
        const objs = codeToObjects.get(code) || [];

        // 표시할 컬럼(기본은 visibleHeaders, 없으면 일부 기본값)
        const cols =
          visibleHeaders && visibleHeaders.length
            ? visibleHeaders
            : [
                "GlobalId",
                "Name",
                "IfcClass",
                "SpatialContainer",
                "총금액",
                "CostItems",
              ];

        const table = document.createElement("table");
        table.className = "summary-child-table";
        table.dataset.code = code;

        const thead = document.createElement("thead");
        const hr = document.createElement("tr");
        cols.forEach((h) => {
          const th = document.createElement("th");
          th.textContent = h.split(".").pop();
          hr.appendChild(th);
        });
        thead.appendChild(hr);
        table.appendChild(thead);

        const tbody = document.createElement("tbody");

        // 값 꺼내는 유틸
        const getVal = (obj, key) => {
          let v = obj[key];
          if (
            v === undefined &&
            obj.Quantities &&
            obj.Quantities[key] !== undefined
          )
            v = obj.Quantities[key];
          if (
            v === undefined &&
            obj.Properties &&
            obj.Properties[key] !== undefined
          )
            v = obj.Properties[key];
          return v;
        };

        if (!summaryGroupBy) {
          // ====== 그룹핑 없음: 기존 그대로 렌더 ======
          objs.forEach((obj) => {
            appendObjRow(obj, tbody, cols);
          });
        } else {
          // ====== 그룹핑 있음 ======
          const groups = {};
          objs.forEach((obj) => {
            let v = getVal(obj, summaryGroupBy);
            if (v === undefined || v === null || v === "") v = "N/A";
            if (!groups[v]) groups[v] = [];
            groups[v].push(obj);
          });

          Object.entries(groups).forEach(([gval, list]) => {
            // 그룹 헤더 행
            const gtr = document.createElement("tr");
            gtr.className = "child-group-header";
            const gtd = document.createElement("td");
            gtd.colSpan = cols.length;
            // 총금액 합계 등 간단 요약
            const totalAmt = list.reduce((s, o) => {
              const n = Number(getVal(o, "총금액"));
              return isNaN(n) ? s : s + n;
            }, 0);
            gtd.textContent = `${summaryGroupBy}: ${gval}  (객체 ${
              list.length
            }개, 총금액 ${formatNumber(totalAmt)} 원)`;
            gtr.appendChild(gtd);
            tbody.appendChild(gtr);

            // 해당 그룹 객체들
            list.forEach((obj) => {
              appendObjRow(obj, tbody, cols);
            });
          });
        }

        table.appendChild(tbody);
        return table;

        // 내부 헬퍼: 객체 한 행 추가 + 클릭 동기화
        function appendObjRow(obj, tbody, cols) {
          const tr = document.createElement("tr");
          const guid =
            obj.GlobalId || obj.globalId || obj.GUID || obj.Guid || "";
          tr.dataset.guid = guid;

          cols.forEach((h) => {
            let v = getVal(obj, h);
            if (typeof v === "number") v = formatNumber(v);
            const td = document.createElement("td");
            td.textContent = v ?? "";
            tr.appendChild(td);
          });

          tr.addEventListener("click", () => {
            if (guid) {
              selectRowsByGuids([guid]);
              if (window.ifcViewer) window.ifcViewer.setSelection([guid]);

              // nested table 선택 스타일
              tbody
                .querySelectorAll("tr")
                .forEach((r) => r.classList.remove("selected-row"));
              tr.classList.add("selected-row");
            }
          });

          tbody.appendChild(tr);
        }
      }

      // 요약표 토글 이벤트(Delegation)
      document.addEventListener("click", (e) => {
        const btn = e.target.closest(".summary-expander-btn");
        if (!btn) return;
        const code = btn.dataset.code;
        if (!code) return;

        if (expandedCodes.has(code)) expandedCodes.delete(code);
        else expandedCodes.add(code);

        // 다시 렌더링
        updateSummaryTableDisplay(latestSummaryData);
      });

      // 숫자 콤마/소수점 포맷 유틸
      function formatNumber(val) {
        if (val === undefined || val === null || val === "") return "";
        const num = Number(val);
        if (isNaN(num)) return val;
        if (Math.abs(num) < 1 && num !== 0) {
          return num.toLocaleString("ko-KR", { maximumFractionDigits: 4 });
        }
        return num.toLocaleString("ko-KR", { maximumFractionDigits: 2 });
      }

      // IFC 저장 (다운로드) (수정된 API 경로)
      document
        .getElementById("saveIFCBtn")
        .addEventListener("click", function () {
          if (confirm("수정된 IFC 파일을 다운로드하시겠습니까?")) {
            window.location.href = `/dd_by_ifc/api/download_ifc/${PROJECT_ID}/`;
          }
        });
    </script>

    <!-- ─────────────────────────────  WASM 기반 IFC Viewer  ───────────────────────────── -->
    <!-- ─────────────────────────────  WASM 기반 IFC Viewer  ───────────────────────────── -->
    <!-- ─────────────────────────────  WASM 기반 IFC Viewer (기준코드 이식판) ───────────────────────────── -->
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

      /* ===================== 유틸: 혹시 남은 구형 스피너 제거 ===================== */
      function hideLegacySpinners() {
        document
          .querySelectorAll("#viewer-loading")
          .forEach((el) => el.remove());
      }

      /* ===================== IFCViewer3D 클래스 (기준코드 완전 이식) ===================== */
      class IFCViewer3D {
        constructor(containerId) {
          this.container = document.getElementById(containerId);
          this.loadingElement = null;
          this.scene = null;
          this.camera = null;
          this.renderer = null;
          this.controls = null;
          this.modelGroup = null;
          this.guidToObject = new Map();
          this.selectionMap = new Map();
          this.selectedGuids = new Set();
          this.onSelectionChange = null;

          this.raycaster = new THREE.Raycaster();
          this.mouse = new THREE.Vector2();
          this.isDragging = false;

          this.highlightMaterial = new THREE.MeshLambertMaterial({
            color: 0xff6b35,
            transparent: true,
            opacity: 0.9,
            side: THREE.DoubleSide,
          });

          this.init();
        }

        init() {
          this.scene = new THREE.Scene();
          this.scene.background = new THREE.Color(0xf5f5f5);

          const aspect =
            this.container.clientWidth / this.container.clientHeight;
          this.camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 5000);
          this.camera.position.set(30, 25, 30);

          this.renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: false,
            powerPreference: "high-performance",
          });
          this.renderer.setSize(
            this.container.clientWidth,
            this.container.clientHeight
          );
          this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          this.renderer.shadowMap.enabled = true;
          this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          this.renderer.outputColorSpace = THREE.SRGBColorSpace;
          this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
          this.renderer.toneMappingExposure = 1.0;
          this.container.appendChild(this.renderer.domElement);

          this.modelGroup = new THREE.Group();
          // 🔧 IFC(Z-up) → three.js(Y-up) 보정
          this.modelGroup.rotation.set(-Math.PI / 2, 0, 0);
          this.modelGroup.updateMatrixWorld(true);
          this.scene.add(this.modelGroup);

          this.setupLighting();
          this.setupControls();
          this.setupEventListeners();

          this.animate();
        }

        setupLighting() {
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
          this.scene.add(ambientLight);

          const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
          directionalLight.position.set(50, 50, 25);
          directionalLight.castShadow = true;
          directionalLight.shadow.mapSize.width = 2048;
          directionalLight.shadow.mapSize.height = 2048;
          directionalLight.shadow.camera.near = 0.5;
          directionalLight.shadow.camera.far = 200;
          directionalLight.shadow.camera.left = -50;
          directionalLight.shadow.camera.right = 50;
          directionalLight.shadow.camera.top = 50;
          directionalLight.shadow.camera.bottom = -50;
          this.scene.add(directionalLight);

          const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
          fillLight.position.set(-25, 20, -25);
          this.scene.add(fillLight);

          const rimLight = new THREE.DirectionalLight(0xffffff, 0.3);
          rimLight.position.set(0, 10, -50);
          this.scene.add(rimLight);
        }

        setupControls() {
          this.controls = new OrbitControls(
            this.camera,
            this.renderer.domElement
          );
          this.controls.enableDamping = true;
          this.controls.dampingFactor = 0.08;
          this.controls.screenSpacePanning = false;

          // Disable default zoom, we implement custom wheel zoom
          this.controls.enableZoom = false;
          this.controls.minDistance = 5;
          this.controls.maxDistance = 500;

          this.controls.enableRotate = true;
          this.controls.rotateSpeed = 0.6;
          this.controls.minPolarAngle = 0.1;
          this.controls.maxPolarAngle = Math.PI - 0.1;

          this.controls.enablePan = true;
          this.controls.panSpeed = 0.8;
          this.controls.keyPanSpeed = 15.0;

          this.controls.mouseButtons = {
            LEFT: THREE.MOUSE.ROTATE,
            MIDDLE: THREE.MOUSE.DOLLY,
            RIGHT: THREE.MOUSE.PAN,
          };
          this.controls.touches = {
            ONE: THREE.TOUCH.ROTATE,
            TWO: THREE.TOUCH.DOLLY_PAN,
          };
          this.controls.autoRotate = false;
          this.controls.autoRotateSpeed = 1.0;
        }

        setupEventListeners() {
          window.addEventListener("resize", () => this.handleResize());
          this.container.addEventListener("contextmenu", (e) =>
            e.preventDefault()
          );
          this.renderer.domElement.addEventListener("click", () => {
            this.renderer.domElement.focus();
          });
          this.renderer.domElement.tabIndex = 0;

          this.renderer.domElement.addEventListener("mousedown", (e) =>
            this.onMouseDown(e)
          );
          this.renderer.domElement.addEventListener("mousemove", (e) =>
            this.onMouseMove(e)
          );
          this.renderer.domElement.addEventListener("mouseup", (e) =>
            this.onMouseUp(e)
          );
          this.renderer.domElement.addEventListener("click", (e) =>
            this.onMouseClick(e)
          );
          this.renderer.domElement.addEventListener("wheel", (e) =>
            this.onMouseWheel(e)
          );

          window.addEventListener("keydown", (event) => {
            if (event.code === "Escape") this.clearSelection();
          });
        }

        handleResize() {
          const width = this.container.clientWidth;
          const height = this.container.clientHeight;
          this.camera.aspect = width / height;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(width, height);
          this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        }

        animate() {
          requestAnimationFrame(() => this.animate());
          if (this.controls) this.controls.update();
          if (this.renderer && this.scene && this.camera) {
            this.renderer.render(this.scene, this.camera);
          }
        }

        updateMousePosition(event) {
          const rect = this.renderer.domElement.getBoundingClientRect();
          this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }

        onMouseWheel(event) {
          event.preventDefault();
          const zoomScale = event.deltaY > 0 ? 1.1 : 0.9;
          this.updateMousePosition(event);
          this.raycaster.setFromCamera(this.mouse, this.camera);
          const intersects = this.raycaster.intersectObjects(
            this.modelGroup.children,
            true
          );
          const pivot =
            intersects.length > 0
              ? intersects[0].point.clone()
              : this.controls.target.clone();

          const camToPivot = new THREE.Vector3().subVectors(
            this.camera.position,
            pivot
          );
          camToPivot.multiplyScalar(zoomScale);
          const newCamPos = new THREE.Vector3().addVectors(pivot, camToPivot);

          const distToTarget = newCamPos.distanceTo(this.controls.target);
          const clampedDist = THREE.MathUtils.clamp(
            distToTarget,
            this.controls.minDistance,
            this.controls.maxDistance
          );
          if (distToTarget !== clampedDist) {
            const dir = new THREE.Vector3()
              .subVectors(newCamPos, this.controls.target)
              .normalize();
            newCamPos
              .copy(this.controls.target)
              .add(dir.multiplyScalar(clampedDist));
          }

          this.camera.position.copy(newCamPos);
          this.controls.update();
        }

        onMouseDown(event) {
          this.isDragging = false;
          this.updateMousePosition(event);
        }
        onMouseMove(event) {
          if (event.buttons > 0) this.isDragging = true;
          this.updateMousePosition(event);
        }
        onMouseUp() {
          if (this.isDragging) {
            this.isDragging = false;
            return;
          }
        }

        onMouseClick(event) {
          if (this.isDragging || event.button !== 0) return;

          this.updateMousePosition(event);
          this.raycaster.setFromCamera(this.mouse, this.camera);

          const hits = this.raycaster.intersectObjects(
            this.modelGroup.children,
            true
          );
          const hit = hits.find((h) => h.object.type !== "LineSegments");
          const additive = event.ctrlKey || event.metaKey || event.shiftKey;

          if (!hit) {
            if (!additive) this.clearSelection();
            return;
          }

          let targetGroup = hit.object;
          while (targetGroup.parent && targetGroup.parent !== this.modelGroup) {
            targetGroup = targetGroup.parent;
          }

          const guid =
            targetGroup?.userData?.ifcGuid ||
            targetGroup?.userData?.GlobalId ||
            targetGroup?.userData?.globalId;

          if (!guid) return;
          this._updateSelectionFromClick(guid, additive);
        }

        _updateSelectionFromClick(guid, additive) {
          let newSet = new Set(this.selectedGuids);
          if (additive) {
            if (newSet.has(guid)) newSet.delete(guid);
            else newSet.add(guid);
          } else {
            newSet = new Set([guid]);
          }
          this.setSelection(Array.from(newSet));
        }

        setSelection(guidsArray) {
          const newSet = new Set(guidsArray);

          // unhighlight removed
          this.selectedGuids.forEach((g) => {
            if (!newSet.has(g)) this._unhighlightByGuid(g);
          });

          // highlight added
          newSet.forEach((g) => {
            if (!this.selectedGuids.has(g)) this._highlightByGuid(g);
          });

          this.selectedGuids = newSet;

          if (typeof this.onSelectionChange === "function") {
            this.onSelectionChange(Array.from(this.selectedGuids));
          }
        }

        _highlightByGuid(guid) {
          const obj = this.guidToObject.get(guid);
          if (!obj) return;

          let mesh = obj;
          if (obj.type === "Group" && obj.children.length > 0)
            mesh = obj.children[0];

          const originalMaterial = mesh.material;
          mesh.material = this.highlightMaterial;

          this.selectionMap.set(guid, {
            object: obj,
            material: originalMaterial,
          });
        }

        _unhighlightByGuid(guid) {
          const entry = this.selectionMap.get(guid);
          if (!entry) return;
          let mesh = entry.object;
          if (mesh.type === "Group" && mesh.children.length > 0)
            mesh = mesh.children[0];
          mesh.material = entry.material;
          this.selectionMap.delete(guid);
        }

        clearSelection() {
          this.setSelection([]);
        }

        showLoading(show, message = "모델 로딩중...") {
          if (show) {
            if (!this.loadingElement) {
              this.loadingElement = document.createElement("div");
              this.loadingElement.id = "ifc-viewer-loading";
              this.loadingElement.style.cssText = `
            position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
            z-index:1000;text-align:center;background:rgba(255,255,255,0.9);
            padding:20px;border-radius:8px;box-shadow:0 4px 8px rgba(0,0,0,0.1);`;
              this.loadingElement.innerHTML = `
            <div style="width:40px;height:40px;border:4px solid #f3f3f3;border-top:4px solid #667eea;border-radius:50%;animation:spin 1s linear infinite;margin:0 auto 10px;"></div>
            <div style="color:#495057;font-weight:600;" id="loading-text">${message}</div>
            <style>@keyframes spin{0%{transform:rotate(0deg);}100%{transform:rotate(360deg);}}</style>`;
              this.container.appendChild(this.loadingElement);
            } else {
              this.loadingElement.querySelector("#loading-text").textContent =
                message;
              this.loadingElement.style.display = "block";
            }
          } else if (this.loadingElement) {
            this.loadingElement.style.display = "none";
            hideLegacySpinners();
          }
        }

        addModelWithEdges(geometry, originalMaterial, userData) {
          const gray = new THREE.Color(0.502, 0.502, 0.502);
          let finalMat;
          if (
            originalMaterial &&
            originalMaterial.color &&
            !originalMaterial.color.equals(new THREE.Color(1, 1, 1)) &&
            !originalMaterial.color.equals(new THREE.Color(0, 0, 0))
          ) {
            finalMat = originalMaterial.clone();
          } else {
            finalMat = new THREE.MeshLambertMaterial({
              color: gray,
              side: THREE.DoubleSide,
              transparent: originalMaterial
                ? originalMaterial.transparent
                : false,
              opacity: originalMaterial ? originalMaterial.opacity : 1.0,
            });
          }

          const mesh = new THREE.Mesh(geometry, finalMat);
          mesh.userData = userData;
          mesh.castShadow = true;
          mesh.receiveShadow = true;

          const edges = new THREE.EdgesGeometry(geometry);
          const edgeMat = new THREE.LineBasicMaterial({
            color: 0x000000,
            transparent: true,
            opacity: 0.4,
            linewidth: 1,
          });
          const wire = new THREE.LineSegments(edges, edgeMat);
          wire.userData = userData;

          const group = new THREE.Group();
          group.add(mesh);
          group.add(wire);
          group.userData = userData;
          return group;
        }

        addModel(object) {
          this.modelGroup.add(object);
          const guid =
            object?.userData?.ifcGuid ||
            object?.userData?.GlobalId ||
            object?.userData?.globalId ||
            null;
          if (guid) this.guidToObject.set(guid, object);
        }

        clearModels() {
          this.clearSelection();
          if (this.modelGroup) {
            while (this.modelGroup.children.length > 0) {
              const child = this.modelGroup.children[0];
              if (child.geometry) child.geometry.dispose();
              if (child.material) {
                if (Array.isArray(child.material))
                  child.material.forEach((m) => m.dispose());
                else child.material.dispose();
              }
              this.modelGroup.remove(child);
            }
          }
        }

        fitCameraToModel() {
          if (!this.modelGroup || this.modelGroup.children.length === 0) {
            this.camera.position.set(30, 25, 30);
            this.camera.lookAt(0, 0, 0);
            this.controls.target.set(0, 0, 0);
            this.controls.update();
            return;
          }

          const box = new THREE.Box3().setFromObject(this.modelGroup);
          const center = box.getCenter(new THREE.Vector3());
          const size = box.getSize(new THREE.Vector3());
          const maxDim = Math.max(size.x, size.y, size.z);
          const fov = this.camera.fov * (Math.PI / 180);
          const distance = Math.abs(maxDim / (2 * Math.tan(fov / 2)));
          const finalDistance = distance * 1.5;

          const phi = Math.PI / 6;
          const theta = Math.PI / 4;
          const x = center.x + finalDistance * Math.sin(phi) * Math.cos(theta);
          const y = center.y + finalDistance * Math.cos(phi);
          const z = center.z + finalDistance * Math.sin(phi) * Math.sin(theta);

          this.camera.position.set(x, y, z);
          this.camera.lookAt(center);

          this.controls.target.copy(center);
          this.controls.minDistance = finalDistance * 0.1;
          this.controls.maxDistance = finalDistance * 5;
          this.controls.update();
        }

        resetView() {
          this.fitCameraToModel();
        }
        toggleAutoRotate() {
          this.controls.autoRotate = !this.controls.autoRotate;
          return this.controls.autoRotate;
        }
        toggleWireframe() {
          this.modelGroup.traverse((child) => {
            if (
              child.type === "Mesh" &&
              child.material &&
              child.material.wireframe !== undefined
            ) {
              child.material.wireframe = !child.material.wireframe;
            }
          });
        }
      }

      /* ===================== 뷰어 인스턴스 생성 ===================== */
      const viewer = new IFCViewer3D("viewer");
      window.ifcViewer = viewer;

      // 뷰어 -> 테이블 동기화
      viewer.onSelectionChange = (guids) => {
        if (window.isSyncingFromTable) return;
        window.isSyncingFromViewer = true;
        window.selectRowsByGuids(guids);
        window.isSyncingFromViewer = false;
      };

      // IFC 로딩 (Pyodide + IfcOpenShell)
      const IFC_URL = "{{ ifc_abs_url }}";
      const WHEEL_URL =
        "{% static 'wasm/IfcOpenShell-0.7.0-py3-none-any.whl' %}";

      function showLoadingStatus(msg) {
        viewer.showLoading(true, msg);
      }

      (async () => {
        hideLegacySpinners();
        try {
          showLoadingStatus("Pyodide 초기화 중...");
          const pyodide = await loadPyodide();
          await pyodide.loadPackage("micropip");
          const micropip = pyodide.pyimport("micropip");

          showLoadingStatus("IfcOpenShell 설치 중...");
          await micropip.install(WHEEL_URL);

          showLoadingStatus("IFC 파일 다운로드 중...");
          const ifcText = await (await fetch(IFC_URL)).text();

          showLoadingStatus("IFC 파싱 중...");
          const ifcopenshell = pyodide.pyimport("ifcopenshell");
          const ifc = ifcopenshell.file.from_string(ifcText);
          const ifcopenshell_geom = pyodide.pyimport("ifcopenshell.geom");

          const settings = ifcopenshell_geom.settings();
          settings.set(settings.WELD_VERTICES, false);

          const iterator = ifcopenshell_geom.iterator(settings, ifc);

          if (iterator.initialize()) {
            showLoadingStatus("3D 지오메트리 생성 중...");
            let geometries = [];
            let lastMeshId = null;
            let processed = 0;

            while (true) {
              const obj = iterator.get();
              const elementType = ifc.by_id(obj.id).is_a();

              if (
                elementType !== "IfcOpeningElement" &&
                elementType !== "IfcSpace"
              ) {
                if (lastMeshId !== obj.geometry.id) {
                  geometries = [];

                  const mats = obj.geometry.materials.toJs().map((mat) => {
                    const diffuse = mat.diffuse.toJs();
                    let hasValidColor = false;
                    if (diffuse.length === 3) {
                      const [r, g, b] = diffuse;
                      hasValidColor = !(
                        (r === 1 && g === 1 && b === 1) ||
                        (r === 0 && g === 0 && b === 0)
                      );
                    }
                    return new THREE.MeshLambertMaterial({
                      color: hasValidColor
                        ? new THREE.Color(...diffuse)
                        : new THREE.Color(0.502, 0.502, 0.502),
                      opacity: 1.0 - mat.transparency,
                      transparent: mat.transparency > 1e-5,
                      side: THREE.DoubleSide,
                    });
                  });

                  const mapping = {};
                  obj.geometry.material_ids.toJs().forEach((mid, idx) => {
                    mapping[mid] = mapping[mid] || [];
                    mapping[mid].push(idx);
                  });

                  const vertices = new Float32Array(obj.geometry.verts.toJs());
                  const normals = new Float32Array(obj.geometry.normals.toJs());
                  const faces = obj.geometry.faces.toJs();

                  let offset = 0;
                  if (mapping[-1]) {
                    mats.unshift(
                      new THREE.MeshLambertMaterial({
                        color: new THREE.Color(0.502, 0.502, 0.502),
                        side: THREE.DoubleSide,
                      })
                    );
                    offset = 1;
                  }

                  mats.forEach((material, mi) => {
                    const idxList = mapping[mi - offset];
                    if (!idxList || idxList.length === 0) return;

                    const geometry = new THREE.BufferGeometry();
                    const indices = [];
                    idxList.forEach((i) => {
                      indices.push(
                        faces[3 * i],
                        faces[3 * i + 1],
                        faces[3 * i + 2]
                      );
                    });
                    geometry.setIndex(indices);
                    geometry.setAttribute(
                      "position",
                      new THREE.BufferAttribute(vertices, 3)
                    );
                    geometry.setAttribute(
                      "normal",
                      new THREE.BufferAttribute(normals, 3)
                    );
                    geometry.computeBoundingSphere();

                    geometries.push([geometry, material]);
                  });

                  lastMeshId = obj.geometry.id;
                }

                geometries.forEach(([geometry, material]) => {
                  const userData = {
                    ifcId: obj.id,
                    ifcType: obj.type,
                    ifcGuid: obj.guid || null,
                    GlobalId: obj.guid || null,
                    elementType,
                  };

                  const meshGroup = viewer.addModelWithEdges(
                    geometry,
                    material,
                    userData
                  );

                  const tm = obj.transformation.matrix.data.toJs();
                  const matrix = new THREE.Matrix4()
                    .set(
                      tm[0],
                      tm[1],
                      tm[2],
                      0,
                      tm[3],
                      tm[4],
                      tm[5],
                      0,
                      tm[6],
                      tm[7],
                      tm[8],
                      0,
                      tm[9],
                      tm[10],
                      tm[11],
                      1
                    )
                    .transpose();

                  meshGroup.matrixAutoUpdate = false;
                  meshGroup.matrix.copy(matrix);

                  viewer.addModel(meshGroup);
                });

                processed++;
                if (processed % 50 === 0)
                  showLoadingStatus(`처리 중... ${processed}개`);
              }

              if (!iterator.next()) break;
            }

            showLoadingStatus(`✅ 모델 로딩 완료! 총 ${processed}개 객체 처리`);

            setTimeout(() => {
              viewer.fitCameraToModel();
              viewer.showLoading(false);
            }, 100);
          } else {
            throw new Error("IFC iterator 초기화 실패");
          }
        } catch (err) {
          console.error("❌ IFC 로딩 실패:", err);
          showLoadingStatus("로딩 실패 - 기본 박스 표시");

          const geometry = new THREE.BoxGeometry(5, 5, 5);
          const material = new THREE.MeshLambertMaterial({
            color: new THREE.Color(0.502, 0.502, 0.502),
            side: THREE.DoubleSide,
          });
          const userData = {
            ifcId: "test",
            ifcType: "Test",
            elementType: "TestBox",
          };
          const test = viewer.addModelWithEdges(geometry, material, userData);
          viewer.addModel(test);
          viewer.fitCameraToModel();
          viewer.showLoading(false);
        } finally {
          hideLegacySpinners();
        }
      })();

      // 디버깅 헬퍼
      window.viewerControls = {
        resetView: () => viewer.resetView(),
        toggleAutoRotate: () => viewer.toggleAutoRotate(),
        toggleWireframe: () => viewer.toggleWireframe(),
        clearSelection: () => viewer.clearSelection(),
        getStats: () => ({
          objects: viewer.modelGroup.children.length,
          triangles: viewer.modelGroup.children.reduce((sum, child) => {
            return (
              sum +
              (child.children?.[0]?.geometry
                ? child.children[0].geometry.index.count / 3
                : 0)
            );
          }, 0),
          selected: Array.from(viewer.selectedGuids),
        }),
      };
      console.log("🎮 viewerControls.* 사용 가능");
    </script>

    <!-- ─────────────────────────────  페이지 전용 스타일 (테이블 축소 등)  ───────────────────────────── -->
    <style>
      .group-header {
        background-color: #e0e0e0 !important;
        font-weight: bold;
        cursor: pointer;
        height: 28px !important;
        font-size: 11px;
      }
      .group-header:hover {
        background-color: #d0d0d0 !important;
      }
      .group-header td {
        height: 28px !important;
        line-height: 28px !important;
      }

      /* ① 공사코드 검색 결과 영역 -------------------------------------------------- */
      .search-results {
        min-height: 180px;
        max-height: 180px;
        overflow-y: auto;
      }
      .search-results li {
        padding: 6px;
        border-bottom: 1px solid #eee;
        cursor: pointer;
        font-size: 11px;
      }
      .search-results li:hover {
        background-color: #f0f0f0;
      }
      .search-results li.selected {
        background-color: #007bff;
        color: white;
      }

      /* 테이블 */

      /* 셀 */

      .column-selector {
        margin-top: 15px;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #f9f9f9;
      }
      .column-selector h4 {
        font-size: 12px;
        margin: 0 0 8px 0;
        color: #333;
      }
      .column-checkboxes {
        max-height: 100px;
        overflow-y: auto;
      }
      .column-checkbox {
        display: flex;
        align-items: center;
        margin-bottom: 3px;
        font-size: 10px;
      }
      .column-checkbox input[type="checkbox"] {
        margin-right: 6px;
        transform: scale(0.8);
      }
      .column-checkbox label {
        cursor: pointer;
        flex: 1;
        font-size: 10px;
      }
      .column-buttons {
        display: flex;
        gap: 5px;
      }
      .btn-small {
        padding: 3px 8px;
        font-size: 10px;
        background-color: #6c757d;
        color: white;
        border: none;
        border-radius: 3px;
        cursor: pointer;
      }
      .btn-small:hover {
        background-color: #5a6268;
      }

      input[type="text"],
      select {
        font-size: 11px;
        padding: 4px 6px;
      }
      .group-bar {
        margin-bottom: 10px;
        font-size: 11px;
      }
      .group-bar label {
        margin-right: 10px;
        font-size: 11px;
      }
      .group-bar select {
        margin-right: 15px;
        font-size: 10px;
        padding: 2px 4px;
      }

      .hidden {
        display: none;
      }
      .left-panel {
        width: 30%;
        padding-right: 15px;
      }
      /* ④ 우측 패널을 세로 flex 레이아웃으로 ------------------------------------ */
      .right-panel {
        display: flex; /* 세로 쌓기 */
        flex-direction: column;
        height: 100%; /* 부모 높이만큼 */
      }

      /* ⑤ IFC 테이블 영역 – 남는 높이 전부 채우기 ------------------------------- */
      #ifcTablecontainer_ {
        flex: 1 1 auto; /* 남는 공간 100% 확보 */
        min-height: 0; /* flex 스크롤 정상 작동용 */
        overflow-y: auto; /* 내용이 넘치면 세로 스크롤 */
        max-height: none !important; /* 기존 inline 400px 제한 해제 */
      }

      .container_detail {
        display: flex;
        margin: 15px 0;
      }
      .btn {
        margin: 4px;
        padding: 6px 12px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 11px;
      }
      .btn:hover {
        background-color: #0056b3;
      }
      .btn-block {
        width: 100%;
        padding: 10px;
        background-color: #28a745;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
      }
      .btn-block:hover {
        background-color: #218838;
      }
      /* ─── 공통 래퍼 ───────────────────────────────────── */
      /* ─── flex 안에서도 100%로 펴지게 ─────────────── */
      .table-wrapper {
        flex: 1 1 100%; /* 남는 폭 모두 차지 */
        width: 100%; /* 부모 div 꽉 차기 */
        overflow-x: auto; /* 넘치면 가로 스크롤 */
      }

      /* ─── AIBIM 통합 테이블 ───────────────────────── */
      .aibim-table {
        width: 100%; /* 기본적으로 꽉 차고               */
        min-width: 1200px; /* 칼럼이 많을 땐 이 기준으로 넘침 */
        border-collapse: collapse;
        font-size: 11px;
        background: #fff;
      }
      .aibim-table th,
      .aibim-table td {
        padding: 4px 6px;
        border: 1px solid #ddd;
        white-space: nowrap;
        text-overflow: ellipsis;
        overflow: hidden;
        height: 24px;
        vertical-align: middle;
        text-align: left;
      }
      .aibim-table th {
        background: #f2f2f2;
        font-weight: bold;
        font-size: 10px;
      }
      .aibim-table tbody tr:nth-child(even) {
        background: #f9f9f9;
      }
      .aibim-table tbody tr:hover {
        background: #e8f4fd;
        cursor: pointer;
      }
      .aibim-table tbody tr.selected {
        background: #007bff !important;
        color: #fff;
      }
      .aibim-table .group-header {
        background: #e0e0e0 !important;
        font-weight: bold;
        cursor: pointer;
      }

      /* ③ 왼쪽의 세 개의 액션 버튼(추가/삭제/열기) ------------------------------ */
      /*   – 빨간색 & 높이 2⁄3 (패딩만 줄이면 됨)                                    */
      #addCodeBtn,
      #removeCodeBtn,
      #loadCodeBtn {
        padding: 4px 10px; /* ← 6 → 4 (높이 ≈ 2⁄3) */
        background: #dc3545; /* Bootstrap danger red */
        border-color: #dc3545;
      }
      #addCodeBtn:hover,
      #removeCodeBtn:hover,
      #loadCodeBtn:hover {
        background: #c82333; /* 조금 더 짙은 빨간색 */
        border-color: #bd2130;
      }
      /* ⑥ 상세 패널 전체 래퍼 – 페이지 남은 높이 모두 차지 */
      html,
      body {
        height: 100%; /* %-height 계산을 위해 필수 */
      }
      #container_detail_first {
        display: flex;
        flex-direction: column; /* 위아래로 쌓기 */
        flex: 1 1 auto; /* 헤더·요약 제외 전부 차지 */
        min-height: 0; /* flex 스크롤 정상 작동 */
      }

      /* ⑦ 좌·우 패널이 들어있는 행도 세로로 늘어나게 */
      #container_detail_first > .container_detail {
        flex: 1 1 auto; /* 남은 공간 전부 */
        min-height: 0; /* flex 스크롤 정상 작동 */
      }

      /* ⑧ 좌·우 개별 패널에도 높이를 전달 */
      .left-panel,
      .right-panel {
        height: 100%;
      }
      /* 3D-Table Selection Sync */
      .object-row.selected-row,
      .aibim-table tbody tr.object-row.selected-row {
        background: #ffe8a1 !important;
      }
      /* ─── Summary expandable rows ───────────────────────────── */
      .summary-expander-btn {
        cursor: pointer;
        border: none;
        background: none;
        font-size: 13px;
        line-height: 1;
        padding: 0;
      }
      .summary-child-row {
        background: #fafafa;
      }
      .summary-child-wrapper {
        padding: 6px 10px 10px 10px;
        background: #fff;
        border: 1px solid #ddd;
        border-radius: 4px;
        max-height: 260px;
        overflow: auto;
      }
      .summary-child-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 10px;
        min-width: 900px;
      }
      .summary-child-table th,
      .summary-child-table td {
        border: 1px solid #ccc;
        padding: 3px 4px;
        white-space: nowrap;
      }
      .summary-child-table tbody tr:hover {
        background: #e8f4fd;
        cursor: pointer;
      }
      .summary-child-table tbody tr.selected-row {
        background: #ffe8a1 !important;
      }
      .expander-col {
        width: 24px;
        text-align: center;
      }
      /* Summary main row 선택 표시 */
      .summary-code-row.selected-main {
        background: #ffe8a1 !important;
      }
      .summary-group-bar label {
        margin-right: 8px;
      }
      .child-group-header {
        background: #f3f3f3 !important;
        font-weight: bold;
      }
    </style>
  </body>
</html>
